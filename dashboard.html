<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DailyRunner.Fun - Dashboard</title>
    <link rel="icon" type="image/png" href="logo.png">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        :root {
            /* Dark mode colors */
            --bg-color: #1c1f1d;
            --widget-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --header-color: #4CAF50;
            --subtext-color: #aaaaaa;
            --border-color: #333333;
            --hover-color: #2c2c2c;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --farm-bg: #361e1ea2;
            --farm-label-bg: #c62828;
            --farm-label-color: white;
            --nsfw-label-bg: #c0392b;
            --nsfw-label-color: white;
            --badge-bg: #3ab929;
            --badge-color: white;
            --copy-bg: #333333;
            --copy-hover-bg: #444444;
            --link-bg: #4bb929;
            --link-hover-bg: #49a823;
            --boost-badge-bg: #6c3483;
            --boost-badge-color: white;
            --scrollbar-thumb: #2e441a;
            --scrollbar-track: rgba(49, 95, 31, 0.2);
            
            /* Stats chart colors */
            --chart-farm-color: rgba(198, 40, 40, 0.8);
            --chart-100k-color: rgba(13, 36, 7, 0.877);
            --chart-250k-color: rgba(46, 204, 113, 0.8);
            --chart-500k-color: rgba(155, 89, 182, 0.8);
            --chart-750k-color: rgba(241, 196, 15, 0.8);
            --chart-1m-color: rgba(230, 126, 34, 0.8);
            --chart-other-color: rgba(189, 195, 199, 0.8);

            --farmed-label-bg: #92833a; /* Yellow for FARMED tags */
            --no-farm-label-bg: #133d15; /* Green for NO FARM DETECTED tags */
        }
        
        /* Stats widget styles */
        .stats-summary {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .stats-label {
            font-weight: bold;
            color: var(--header-color);
        }
        
        .stats-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 5px;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        h1 {
            color: var(--header-color);
            margin: 0;
        }
        .page-title {
            font-size: 1.75rem;
            color: var(--header-color);
            margin-bottom: 5px;
            text-align: center;
            padding: 5px 0;
            border-bottom: 2px solid var(--border-color);
        }
        .status {
            font-size: 14px;
            color: var(--subtext-color);
        }
        .widget {
            background: var(--widget-bg);
            border-radius: 8px;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-bottom: 8px;
            flex: 0 0 calc(33.333% - 8px); /* Fixed width instead of flexible */
            min-width: 250px; /* Lower minimum to prevent unwanted wrapping */
            max-width: 100%; /* Ensure widget doesn't exceed container width */
            display: flex;
            flex-direction: column;
            max-height: 450px;
            overflow: hidden;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        .widget-header-container {
            position: sticky;
            top: 0;
            background: var(--widget-bg);
            z-index: 10;
            padding: 10px 10px 0 10px;
            border-radius: 8px 8px 0 0;
            transition: background-color 0.3s ease;
        }
        
        /* Custom scrollbar styles */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--link-hover-bg);
        }
        
        /* Firefox scrollbar (limited support) */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
        
        .token-list-container {
            overflow-y: auto;
            padding: 0 10px 10px 10px;
            flex: 1;
            scrollbar-width: thin;
        }
        .widget-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: border-color 0.3s ease;
        }
        
        .widget-header h3 {
            font-size: 1rem;
            margin: 0;
            color: var(--header-color);
            transition: color 0.3s ease;
        }
        
        .filter-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .filter-control {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .filter-control label {
            font-size: 0.75rem;
            color: var(--subtext-color);
            white-space: nowrap;
            transition: color 0.3s ease;
        }
        
        .sortable {
            cursor: pointer;
            position: relative;
            padding-right: 15px;
            display: flex;
            justify-content: center;
            width: 30px;
        }
        
        .sortable:after {
            content: "↕";
            position: relative;
            opacity: 0.5;
            margin-left: 3px;
        }
        
        .sortable.asc:after {
            content: "↑";
            opacity: 1;
        }
        
        .sortable.desc:after {
            content: "↓";
            opacity: 1;
        }
        
        #sort-graduated {
            display: flex;
            justify-content: center;
            width: 30px;
        }
        .widgets-row {
            display: flex;
            flex-wrap: wrap; /* Allow widgets to wrap to new rows */
            gap: 8px;
            margin-bottom: 10px;
            width: 100%;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        .token-row {
            display: grid;
            grid-template-columns: 40px minmax(120px, 1fr) 80px;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #ecf0f1;
            transition: background-color 0.3s ease;
        }
        
        .token-header {
            display: grid;
            grid-template-columns: 40px minmax(120px, 1fr) 80px;
            align-items: center;
            padding: 6px 0;
            border-bottom: 2px solid var(--border-color);
            font-weight: bold;
            background: var(--widget-bg);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        /* Updated token row structure */
        .token-row, .token-header, .token-row-with-boost {
            display: grid;
            grid-template-columns: 40px minmax(120px, 1fr) 80px;
            align-items: start; /* Changed from center to start to improve vertical alignment */
            padding: 2px 0 2px 0; /* Changed from padding: 10px 0 */
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }

        /* Adjust the image container to move up a bit */
        .token-image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px; /* Reduced from 5px */
            padding-top: 1px; /* Added padding at top */
        }

        /* Add a container for the token details section */
        .token-details-container {
            display: flex;
            flex-direction: column;
            gap: 0; /* No gap */
        }

        /* Adjust token info to remove bottom margin */
        .token-info {
            display: flex;
            flex-direction: column;
            gap: 0px;
            margin-bottom: 0;
        }

        /* Move metrics to span across the grid */
        /* Metric tag styles */
        .metric-tag {
            display: inline-block;
            padding: 0px 1px;
            border-radius: 2px;
            font-size: 0.55rem;
            font-weight: bold;
            margin-right: 1px;
            color: white;
        }

        .sus-tag {
            background-color: #e74c3c; /* Red for SUS */
        }

        .dev-tag {
            background-color: #116b59; /* Teal for DEV */
        }

        .insider-tag {
            background-color: #976513; /* Gold for INSIDER */
        }

        .token-metrics-container {
            grid-column: 1 / 3; /* Span from column 1 to column 3 */
            text-align: left;
            padding-top: 0px;
            padding-left: 0;
            margin-top: 0px;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        /* Update the token metrics style */
        .token-metrics {
            font-size: 0.65rem;
            color: var(--subtext-color);
            margin-top: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s ease;
            padding-left: 0;
        }
        
        /* Ensure the MC column is properly centered */
        .token-header > div:last-child {
            text-align: center;
        }
        .token-image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0px;
        }
        .graduation-time {
            font-size: 0.65rem;
            color: var(--subtext-color);
            text-align: center;
            transition: color 0.3s ease;
        }
        .token-row:hover {
            background-color: var(--hover-color);
            transition: background-color 0.3s ease;
        }
        .token-row:last-child {
            border-bottom: none;
        }
        .token-image {
            width: 40px;
            height: 40px;
            border-radius: 22%;
            object-fit: cover;
        }
        .token-name {
            font-size: 0.85rem;
            font-weight: bold;
            color: var(--header-color);
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s ease;
        }
        
        .token-name-link {
            color: inherit;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .token-name-link:hover {
            color: var(--link-bg);
            text-decoration: underline;
        }

        /* Fix any layout issues that might occur when converting to links */
        .token-info-container h3 {
            margin: 0;
            padding: 0;
            display: inline-block;
        }
        .token-info {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        
        .token-details {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .token-social {
            display: flex;
            gap: 4px;
            margin-top: 1px;
        }
        .token-symbol {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin: 0;
        }
        .abbreviated-address {
            font-size: 0.7rem;
            color: #95a5a6;
            margin: 0 3px;
            font-family: monospace;
        }
        .copy-icon {
            cursor: pointer;
            background-color: #ecf0f1;
            border-radius: 50%;
            width: 10px;
            height: 10px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: #7f8c8d;
            transition: all 0.2s ease;
        }
        .copy-icon:hover {
            background-color: #d5dbdb;
        }
        .copy-tooltip {
            position: absolute;
            background-color: var(--header-color);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .copy-tooltip.visible {
            opacity: 1;
        }
        .price-col, .marketcap-col {
            text-align: right;
        }
        
        .marketcap-col.sortable {
            display: flex;
            justify-content: center;
            text-align: center;
            width: auto;
            padding-right: 15px;
        }
        .marketcap-value {
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--header-color);
            transition: color 0.3s ease;
        }
        .marketcap-label {
            font-size: 0.65rem;
            color: var(--subtext-color);
            transition: color 0.3s ease;
        }
        .time-since {
            text-align: right;
            font-size: 0.9rem;
            color: var(--header-color);
            padding-right: 25px;
            transition: color 0.3s ease;
        }
        .empty-state {
            text-align: center;
            padding: 0px;
            color: var(--subtext-color);
            transition: color 0.3s ease;
        }
        .social-links-header {
            padding-left: 25px;
        }
        
        .token-links {
            display: flex;
            gap: 10px;
            justify-content: flex-start;
            padding-left: 25px;
        }
        .token-link {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 9px;
            text-decoration: none;
            color: #fff;
            background-color: var(--link-bg);
            transition: background-color 0.3s ease;
        }
        .token-link:hover {
            background-color: var(--link-hover-bg);
        }
        .token-link i {
            font-size: 10px;
        }
        
        /* Farm token indication */
        .farm-token {
            background-color: var(--farm-bg);
            transition: background-color 0.3s ease;
        }
        
        .farm-label {
            display: inline-block;
            background-color: var(--farm-label-bg);
            color: var(--farm-label-color);
            padding: 1px 5px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.55rem;
            margin-left: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .instafarmed-label {
            display: inline-block;
            background-color: var(--farmed-label-bg);
            color: var(--farm-label-color);
            padding: 1px 5px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.55rem;
            margin-left: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .token-info-container {
            display: flex;
            align-items: flex-start;
        }
        
        .token-metrics {
            font-size: 0.55rem;
            color: var(--subtext-color);
            margin-top: 0px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s ease;
        }

        @media (max-width: 1400px) {
            .token-metrics {
                font-size: 0.55rem;
            }
        }

        @media (max-width: 1200px) {
            .token-metrics {
                font-size: 0.55rem;
            }
        }

        /* Media queries for better responsiveness */
        @media (max-width: 1600px) {
            .token-symbol, .abbreviated-address {
                font-size: 0.75rem;
            }
            
            .token-row, .token-header {
                grid-template-columns: 40px minmax(120px, 1fr) 80px;
            }
            
            .farm-label, .instafarmed-label {
                font-size: 0.55rem;
                padding: 1px 5px;
            }
        }
        
        /* 1x6 configuration (largest screens) */
        @media (min-width: 1800px) {
            #all-widgets .widget {
                flex: 0 0 calc(16.666% - 8px); /* Exactly 6 widgets per row */
                width: calc(16.666% - 8px);
            }
        }

        /* 2x3 configuration (medium-large screens) */
        @media (max-width: 1799px) and (min-width: 1200px) {
            #all-widgets .widget {
                flex: 0 0 calc(33.333% - 8px); /* Exactly 3 widgets per row */
                width: calc(33.333% - 8px);
            }
        }

        /* 3x2 configuration (medium screens) */
        @media (max-width: 1199px) and (min-width: 768px) {
            #all-widgets .widget {
                flex: 0 0 calc(50% - 8px); /* Exactly 2 widgets per row */
                width: calc(50% - 8px);
            }
        }

        /* 6x1 configuration (small screens) */
        @media (max-width: 767px) {
            #all-widgets .widget {
                flex: 0 0 100%; /* Exactly 1 widget per row */
                width: 100%;
            }
        }
        
        /* Make sure other rows of widgets follow the same pattern */
        #stats-widgets-row .widget,
        #history-widget-row .widget {
            min-width: 300px;
            flex: 1 1 calc(50% - 8px); /* 2 widgets per row for these sections */
        }
        
        /* Ensure token rows inside widgets respect the widget's width */
        .token-row, 
        .token-header, 
        .token-row-with-boost {
            width: 100%;
            min-width: 0; /* Allow grid to shrink below its minimum content size */
        }
        
        /* Make sure token columns also adjust properly */
        .marketcap-col {
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .threshold-amount {
            font-weight: bold;
            color: var(--header-color);
            transition: color 0.3s ease;
        }
        
        .threshold-badge {
            display: inline-block;
            background-color: var(--badge-bg);
            color: var(--badge-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 10px;
            font-weight: bold;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* New style for widgets */
        .dex-paid-widget, .dex-boosts-widget {
            margin-top: 20px;
        }
        
        .coming-soon-widget {
            background: var(--widget-bg);
            border: 2px dashed var(--border-color);
            opacity: 0.9;
        }

        .coming-soon-message {
            text-align: center;
            color: var(--subtext-color);
            max-width: 90%;
        }

        .coming-soon-message p {
            font-size: 1rem;
            line-height: 1.5;
            margin-top: 15px;
        }

        .coming-soon-icon {
            font-size: 2.5rem;
            display: block;
            margin-bottom: 10px;
        }
        
        .nsfw-badge {
            display: inline-block;
            background-color: #e74c3c;
            color: white;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.65rem;
            margin-left: 5px;
            font-weight: bold;
        }
        
        .reply-count {
            font-size: 0.65rem;
            color: #7f8c8d;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .reply-count-icon {
            font-size: 0.8rem;
        }

        /* New styles for boost badges */
        .boost-badge {
            display: inline-block;
            background-color: var(--boost-badge-bg);
            color: var(--boost-badge-color);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.65rem;
            margin-left: 4px;
            font-weight: bold;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .boost-info {
            display: flex;
            align-items: center;
            font-size: 0.65rem;
            color: var(--subtext-color);
            gap: 3px;
            margin-top: 1px;
        }
        
        .boost-icon {
            font-size: 0.8rem;
        }
        
        .token-row-with-boost {
            display: grid;
            grid-template-columns: 40px minmax(120px, 1fr) 80px;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s ease;
        }
        
        .token-row-with-boost:hover {
            background-color: var(--hover-color);
        }
        
        .token-row-with-boost:last-child {
            border-bottom: none;
        }

        /* Boost level indicator colors */
        .boost-high {
            background-color: #8e44ad;
        }
        
        .boost-medium {
            background-color: #2980b9;
        }
        
        .boost-low {
            background-color: #27ae60;
        }
        #history-widget-row {
            margin-top: 20px;
        }
        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .stats-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color);
            min-width: 50px; /* Creates a minimum width for the value area */
            text-align: right; /* Aligns all values to the right */
            margin-left: 20px; /* Adds explicit space between label and value */
        }
        /* Add this CSS to your stylesheet */

        /* Bottom widgets styling - target the specific row containing the DEX widgets and Coming Soon */
        .widgets-row:last-of-type {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
            width: 100%;
        }

        /* Base styles for the bottom three widgets */
        .dex-paid-widget,
        .dex-boosts-widget,
        .coming-soon-widget {
            flex: 1 1 calc(33.333% - 8px);
            min-width: 300px; /* Minimum width to prevent too narrow widgets */
            max-width: 100%;
        }

        /* Large screens (3 widgets per row) */
        @media (min-width: 1200px) {
            .widgets-row:last-of-type .widget {
                flex: 1 1 calc(33.333% - 8px);
            }
        }

        /* Medium screens (2 widgets per row) */
        @media (max-width: 1199px) and (min-width: 769px) {
            .widgets-row:last-of-type .widget {
                flex: 1 1 calc(50% - 8px);
            }
            
            /* Make the "coming soon" widget take full width when in 2-column layout */
            .widgets-row:last-of-type .widget:last-child {
                flex: 0 0 100%;
            }
        }

        /* Small screens (1 widget per row) */
        @media (max-width: 768px) {
            .widgets-row:last-of-type .widget {
                flex: 0 0 100%;
            }
        }

        /* Ensure content inside the widgets scales properly */
        .token-row, 
        .token-header, 
        .token-row-with-boost {
            width: 100%;
            min-width: 0; /* Allow grid to shrink below minimum content size */
        }

        /* Prevent horizontal scrolling in the token lists */
        .token-list-container {
            overflow-x: hidden;
        }

        /* Remove the default min-width for these specific widgets to let our media queries control it */
        .dex-paid-widget,
        .dex-boosts-widget,
        .coming-soon-widget {
            min-width: 0;
        }
        
        /* Filter Dropdown Styles */
        .filter-dropdown-container {
            position: relative;
            display: inline-block;
        }

        .filter-dropdown-button {
            background-color: var(--badge-bg);
            color: var(--badge-color);
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        .filter-dropdown-button:hover {
            background-color: var(--link-hover-bg);
        }

        .filter-dropdown-arrow {
            margin-left: 5px;
            font-size: 0.7rem;
            transition: transform 0.3s ease;
        }

        .filter-dropdown-arrow.open {
            transform: rotate(180deg);
        }

        .filter-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            background-color: var(--widget-bg);
            min-width: 160px;
            box-shadow: 0 4px 8px var(--shadow-color);
            z-index: 100;
            border-radius: 4px;
            padding: 8px 0;
            margin-top: 5px;
            border: 1px solid var(--border-color);
        }

        .filter-dropdown-content.show {
            display: block;
        }

        .filter-dropdown-content .filter-control {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }

        .filter-dropdown-content .filter-control:hover {
            background-color: var(--hover-color);
        }

        .filter-dropdown-content label {
            margin-left: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-color);
        }

        .filter-dropdown-content input[type="checkbox"] {
            cursor: pointer;
        }
        /* Token History Column Styles */
        .token-history-col {
            padding: 0 10px;
            max-width: 100%;
            white-space: nowrap;
            overflow-x: auto;
            scrollbar-width: thin;
            display: flex;
            gap: 4px;
            align-items: center;
            min-height: 40px;
        }

        .history-tag {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.55rem;
            font-weight: bold;
            margin-right: 2px;
            white-space: nowrap;
        }

        /* Make the history column text wrap for smaller screens */
        @media (max-width: 768px) {
        #history-widget .token-row,
        #history-widget .token-header {
            grid-template-columns: 40px minmax(700px, 0.1fr) minmax(50px, 2.5fr) 80px 80px !important;
        }
            
        .token-history-col {
            flex-wrap: wrap;
            white-space: normal;
            overflow-x: hidden;
        }

        .history-tag {
            margin-bottom: 0px;
            font-size: 0.55rem;
        }
        }
        /* Styles for history items and timestamps */
        .history-item {
            display: flex;
            flex-direction: column;
            margin-right: 2px;
            margin-bottom: 0px;
        }

        .history-timestamp {
            font-size: 0.6rem;
            color: var(--subtext-color);
            margin-top: 0px;
            margin-left: 2px;
            white-space: nowrap;
        }

        /* Update token-history-col to support the new structure */
        .token-history-col {
            padding: 0 10px;
            max-width: 100%;
            white-space: normal;
            overflow-x: auto;
            scrollbar-width: thin;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: flex-start;
            min-height: 40px;
        }

        /* Media query for smaller screens */
        @media (max-width: 768px) {
            .history-item {
                margin-bottom: 0px;
            }
            
            .history-timestamp {
                font-size: 0.55rem;
            }
            /* Hide the Highest Threshold column */
            #history-widget .token-header > div:nth-child(4),
            #history-widget .token-row > div.highest-threshold-col {
                display: none !important;
            }
        }/* Search Bar Styles */
        .history-search-container {
            display: flex;
            align-items: center;
            margin-left: auto;
            margin-right: 10px;
        }

        #historySearchInput {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--widget-bg);
            color: var(--text-color);
            width: 150px;
            transition: width 0.3s ease;
        }

        #historySearchInput:focus {
            width: 180px;
            outline: none;
            border-color: var(--badge-bg);
        }

        #historySearchInput::placeholder {
            color: var(--subtext-color);
            opacity: 0.7;
        }
        #history-widget {
            max-height: 700px; /* or any height you prefer */
        }

        #history-widget .token-list-container {
            max-height: calc(100% - 100px); /* Adjust the inner container as well */
        }
        /* Target both the token row and header in the history widget */
        #history-widget .token-row,
        #history-widget .token-header {
        /* Adjust the grid template columns to give more space to Scan History */
        grid-template-columns: 40px minmax(145px, 1fr) minmax(220px, 2.2fr) 100px 80px !important;
        }

        /* Ensure token info text truncates properly */
        #history-widget .token-name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        }

        /* Make sure the history column has proper overflow behavior */
        .token-history-col {
        overflow-x: auto;
        max-width: 100%;
        }
        .incomplete-scan-token {
            background-color: #431c52 !important; /* Purple color, !important to override farm-token */
            transition: background-color 0.3s ease;
        }
        .black-placeholder {
            background-color: #000;
            width: 40px;
            height: 40px;
            border-radius: 22%;
            display: block;
        }
        .black-placeholder {
            background-color: #000;
            width: 40px;
            height: 40px;
            border-radius: 22%;
            display: block;
        }
        .no-farm-label {
            display: inline-block;
            background-color: var(--no-farm-label-bg);
            color: var(--farm-label-color);
            padding: 1px 5px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.55rem;
            margin-left: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Mobile Responsive Styles for Graduated Token History */
        @media (max-width: 480px) {
            /* Adjust the grid template columns for history widget - remove the Highest column */
            #history-widget .token-header,
            #history-widget .token-row {
                grid-template-columns: 40px minmax(100px, 1fr) minmax(100px, 1.5fr) 70px !important;
            }
            
            /* Hide the Highest Threshold column */
            #history-widget .token-header > div:nth-child(4),
            #history-widget .token-row > div.highest-threshold-col {
                display: none !important;
            }
            
            /* Adjust scan history column */
            .token-history-col {
                padding: 0 3px;
                gap: 4px;
            }
            
            /* Make history items more compact */
            .history-item {
                margin-right: 4px;
                margin-bottom: 0;
            }
            
            /* Reduce font sizes */
            #history-widget .token-name {
                font-size: 0.75rem;
            }
            
            .token-symbol, .abbreviated-address {
                font-size: 0.65rem;
            }
            
            .history-tag {
                font-size: 0.5rem;
                padding: 1px 3px;
                margin-right: 1px;
            }
            
            .history-timestamp {
                font-size: 0.5rem;
            }
            
            /* Adjust filter and search elements */
            .filter-dropdown-content {
                width: 250px;
                right: -50px;
            }
            
            #history-widget .history-search-container input {
                width: 120px;
            }
            
            /* Adjust marketcap column */
            .marketcap-value {
                font-size: 0.7rem;
            }
            
            .marketcap-label {
                font-size: 0.55rem;
            }
            
            /* Adjust color key */
            .history-color-key {
                flex-wrap: wrap;
                font-size: 0.6rem;
            }
            
            .key-item {
                margin-bottom: 3px;
            }
        }

        /* Tablet-specific adjustments */
        @media (min-width: 481px) and (max-width: 768px) {
            /* Push market cap column more to the right */
            #history-widget .token-header,
            #history-widget .token-row {
                /* Adjust column distribution - give more weight to scan history and less to token */
                grid-template-columns: 40px minmax(120px, 1.2fr) minmax(120px, 1.7fr) 80px !important;
            }
            
            /* Add left padding to create more space between scan history and market cap */
            .marketcap-col {
                padding-left: 2px;
                justify-self: end; /* Right-align the market cap column */
            }
            
            /* Ensure market cap text aligns properly */
            .marketcap-value, .marketcap-label {
                text-align: right;
            }
            
            /* Reduce padding in history column to allow more space overall */
            .token-history-col {
                padding: 0 2px;
            }
                /* Hide the token symbol completely */
            .token-symbol {
                display: none;
            }
        }
        /* Default style - full labels visible */
        .metric-tag .full-label {
            display: inline;
        }
        .metric-tag .short-label {
            display: none;
        }
        
        /* Mobile style - only for history widget */
        @media (max-width: 768px) {
            #history-widget .metric-tag .full-label {
                display: none;
            }
            #history-widget .metric-tag .short-label {
                display: inline;
            }
        }
        .page-title {
            font-size: 1.75rem;
            color: var(--header-color);
            margin-bottom: 5px;
            text-align: center;
            padding: 5px 0;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .header-logo {
            height: 1.5em;
            width: auto;
            margin-right: 10px;
            vertical-align: middle;
        }
        /* Dropdown Menu Styles */
        .menu-dropdown {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
        }

        .menu-button {
            background: linear-gradient(135deg, #4CAF50, #2196F3);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-family: 'Arial', sans-serif;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        .menu-button svg {
            width: 16px;
            height: 16px;
            margin-right: 6px;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background-color: rgba(36, 36, 36, 0.95);
            min-width: 160px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            z-index: 101;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dropdown-content a {
            color: white;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            transition: background-color 0.2s;
        }

        .dropdown-content a:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }

        .show {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        /* Optional: Add separator between Dashboard and other menu items */
        .dropdown-content a.separator-top {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 4px;
            padding-top: 12px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Media queries for responsive menu */
        @media (max-width: 768px) {
            .menu-button {
                padding: 6px 10px;
                font-size: 0.8em;
            }
            
            .menu-button svg {
                width: 14px;
                height: 14px;
            }
        }

        @media (max-width: 480px) {
            .menu-button {
                padding: 5px 8px;
                font-size: 0.7em;
            }
            
            .menu-button svg {
                width: 12px;
                height: 12px;
            }
            
            .dropdown-content {
                min-width: 140px;
            }
            
            .dropdown-content a {
                padding: 10px 14px;
                font-size: 0.9em;
            }
        }
        /* Launch Pad Selector Styles */
        .launch-pad-selector {
            display: flex;
            align-items: center;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #launch-pad-selector {
            padding: 4px 8px;
            border-radius: 4px;
            background-color: var(--widget-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            cursor: pointer;
        }

        #launch-pad-selector:focus {
            outline: none;
            border-color: var(--badge-bg);
        }

        #launch-pad-selector option {
            background-color: var(--widget-bg);
            color: var(--text-color);
        }
        .meteora-badge {
            background-color: #9370DB; /* Purple for Meteora */
            color: #ffffff;
        }
        /* Hide DEX Paid tags in the token column (next to social links)*/
        /*.dex-paid-tag {
            display: none !important;
        }

        /* Hide DEX Paid tags in the scan history column */
        /*.history-tag:contains("Dex Paid"),   /* This selector might not work in all browsers */
        /*.history-item .history-tag[style*="background-color: #0e0e0e"] {
            display: none !important;
        }

        /* Hide the parent history-item if it only contains a Dex Paid tag */
        /*.history-item:has(.history-tag[style*="background-color: #0e0e0e"]) {
            display: none !important;
        }
        /* Hide the filter option */
        /*.filter-control:has(#historyShowDexPaidOnly),
        .filter-control:has([name="historyShowDexPaidOnly"]) {
        display: none !important;
        }

        #historyShowDexPaidOnly,
        input[name="historyShowDexPaidOnly"],
        label[for="historyShowDexPaidOnly"] {
        display: none !important;
        }
        /*Hide the entire toggle container */
        .time-toggle-container {
            display: none !important;
        }
        /* Hide bottom widgets REMOVE FOR PRIVATE USE*/
        #dex-paid-widget, #dex-boosts-widget, #coming-soon-widget {
            display: none !important;
        }
        /* Hide time since tags in scan history */
        .token-history-col .history-item .history-timestamp {
            display: none !important;
        }
        /* Hide specific widgets while keeping Graduated Token History visible */
        #graduated-widget {
            display: none !important;
        }

        .widget#graduated-widget {
            display: none !important;
        }

        .threshold-widget {
            display: none !important;
        }

        #dex-paid-widget {
            display: none !important;
        }

        #dex-boosts-widget {
            display: none !important;
        }

        #coming-soon-widget {
            display: none !important;
        }

        .coming-soon-widget {
            display: none !important;
        }

        /* Also hide the threshold sort dropdown since threshold widgets are hidden */
        .threshold-sort-container {
            display: none !important;
        }

        /* Hide the entire bottom widgets row that contains DEX widgets and coming soon */
        .widgets-row:last-of-type {
            display: none !important;
        }
    </style>
    <!-- DDoS Protection Script - Added for security without changing page appearance -->
    <script src="ddos-protection.js" defer></script>
</head>
<body>
    <div class="menu-dropdown">
        <button class="menu-button" onclick="toggleMenu()">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
                <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
            </svg>
            Menu
        </button>
        <div id="dropdown-menu" class="dropdown-content">
            <a href="/">Home Page</a>
            <a href="/dashboard.html">Dashboard</a>
            <a href="/trending.html">Trending</a>
            <a href="/documentation.html">Documentation</a>
            <a href="/privacy.html" class="separator-top">Privacy Policy</a>
            <a href="/disclaimer.html">Disclaimer</a>
            <a href="/termsofservice.html">Terms of Service</a>
        </div>
    </div>
    <div class="container">
        <h1 class="page-title"><img src="logo.png" alt="Logo" class="header-logo">DAILYRUNNER.FUN DASHBOARD</h1>
        
        <!-- Dark Mode Toggle and Last Updated -->
        <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
            <div style="display: flex; flex-direction: column; align-items: flex-end;">
                <div class="status">Last updated: <span id="last-updated">Never</span></div>
            </div>
        </div>
        
        <!-- Stats Widgets (Farm Ratio and Threshold Stats) -->
        <div class="widgets-row" id="stats-widgets-row">
            <!-- Farm vs Non-Farm Ratio Widget - Now comes first (left) -->
            <div class="widget" id="farm-ratio-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>Daily Farm Ratio</h3>
                        <div class="status" style="display:none;"><span id="stats-last-updated">Never</span></div>
                    </div>
                </div>
                
                <div class="widget-content" style="display: flex; padding: 15px; justify-content: center;">
                    <div style="width: 400px; height: 250px; position: relative;">
                        <canvas id="farmRatioChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- 48 Hour Threshold Stats Widget - Now comes second (right) -->
            <div class="widget" id="threshold-stats-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>Daily Threshold Stats</h3>
                        <div class="status" style="display:none;"><span id="threshold-stats-last-updated">Never</span></div>
                    </div>
                </div>
                
                <div class="widget-content" style="display: flex; padding: 15px; justify-content: center;">
                    <div class="stats-summary">
                        <div class="stats-row">
                            <span class="stats-label">Total Graduated:</span>
                            <span class="stats-value" id="stats-total-graduated">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">Farm Tokens:</span>
                            <span class="stats-value" id="stats-farm-tokens">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">Non-Farm Tokens:</span>
                            <span class="stats-value" id="stats-non-farm-tokens">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">$100K+ Threshold:</span>
                            <span class="stats-value" id="stats-100k">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">$250K+ Threshold:</span>
                            <span class="stats-value" id="stats-250k">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">$500K+ Threshold:</span>
                            <span class="stats-value" id="stats-500k">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">$750K+ Threshold:</span>
                            <span class="stats-value" id="stats-750k">0</span>
                        </div>
                        <div class="stats-row">
                            <span class="stats-label">$1M+ Threshold:</span>
                            <span class="stats-value" id="stats-1m">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div> <!-- End of stats-widgets-row -->

<div class="widgets-row" id="history-widget-row">
    <div class="widget" id="history-widget">
        <div class="widget-header-container">
<div class="widget-header">
                <h3>Graduated Token History</h3>
                <div class="filter-dropdown-container">
                    <button class="filter-dropdown-button" id="historyFilterButton">
                        <span>FILTER</span>
                        <span class="filter-dropdown-arrow">▼</span>
                    </button>
                    <div class="filter-dropdown-content" id="historyFilterDropdown">
                        <div class="filter-control">
                            <input type="checkbox" id="historyHasSocialLinks" name="historyHasSocialLinks">
                            <label for="historyHasSocialLinks">PumpFun Socials</label>
                        </div>
                        <div class="filter-control">
                            <input type="checkbox" id="historyExcludeFarmTokens" name="historyExcludeFarmTokens">
                            <label for="historyExcludeFarmTokens">No FARMS</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Column Headers -->
            <div class="token-header">
                <div class="sortable" id="sort-history-timestamp"></div>
                <div>Token</div>
                <div>Scan History</div>
                <div class="marketcap-col sortable" id="sort-history-market-cap">MC</div>
            </div>
        </div>
        
        <div class="token-list-container">
            <div id="history-tokens-list">
                <div class="empty-state">Loading token history...</div>
            </div>
        </div>
    </div>
</div>
        
        <header>
            <h2></h2>
        </header>
        
        <div class="widgets-row" id="all-widgets">
            <div class="widget" id="graduated-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>Graduated</h3>
                        <div class="filter-controls">
                            <div class="filter-control">
                                <input type="checkbox" id="hasSocialLinks" name="hasSocialLinks">
                                <label for="hasSocialLinks">Socials</label>
                            </div>
                            <div class="filter-control">
                                <input type="checkbox" id="excludeFarmTokens" name="excludeFarmTokens">
                                <label for="excludeFarmTokens">No FARMS</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Column Headers -->
                    <div class="token-header">
                        <div class="sortable" id="sort-graduated"></div>
                        <div>Token</div>
                        <div class="marketcap-col sortable" id="sort-market-cap">MC</div>
                    </div>
                </div>
                
                <div class="token-list-container">
                    <div id="tokens-list">
                        <div class="empty-state">Loading tokens...</div>
                    </div>
                </div>
            </div>
            
            <!-- Threshold widgets will be dynamically inserted here -->
        </div>
        
        <!-- Bottom Widgets Row - KOL BUYS WIDGET REMOVED -->
        <div class="widgets-row">
            <!-- DEX Paid Widget -->
            <div class="widget dex-paid-widget" id="dex-paid-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>DEX Paid</h3>
                        <div class="filter-controls">
                            <div class="filter-control">
                                <input type="checkbox" id="dexHasSocialLinks" name="dexHasSocialLinks">
                                <label for="dexHasSocialLinks">Socials</label>
                            </div>
                            <div class="filter-control">
                                <input type="checkbox" id="dexExcludeFarmTokens" name="dexExcludeFarmTokens">
                                <label for="dexExcludeFarmTokens">No FARMS</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Column Headers -->
                    <div class="token-header">
                        <div class="sortable" id="sort-dex-timestamp"></div>
                        <div>Token</div>
                        <div class="marketcap-col sortable" id="sort-dex-market-cap">MC</div>
                    </div>
                </div>
                
                <div class="token-list-container">
                    <div id="dex-tokens-list">
                        <div class="empty-state">Loading DEX paid tokens...</div>
                    </div>
                </div>
            </div>
            
            <!-- DEX Ad Boosts Widget -->
            <div class="widget dex-boosts-widget" id="dex-boosts-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>DEX Ad Boosts</h3>
                        <div class="filter-controls">
                            <div class="filter-control">
                                <input type="checkbox" id="boostHasSocialLinks" name="boostHasSocialLinks">
                                <label for="boostHasSocialLinks">Socials</label>
                            </div>
                            <div class="filter-control">
                                <input type="checkbox" id="boostExcludeFarmTokens" name="boostExcludeFarmTokens">
                                <label for="boostExcludeFarmTokens">No FARMS</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Column Headers -->
                    <div class="token-header">
                        <div class="sortable" id="sort-boost-timestamp"></div>
                        <div>Token</div>
                        <div class="marketcap-col sortable" id="sort-boost-market-cap">MC</div>
                    </div>
                </div>
                
                <div class="token-list-container">
                    <div id="boost-tokens-list">
                        <div class="empty-state">Loading DEX ad boost tokens...</div>
                    </div>
                </div>
            </div>
            
            <!-- More Coming Soon Widget -->
            <div class="widget coming-soon-widget" id="coming-soon-widget">
                <div class="widget-header-container">
                    <div class="widget-header">
                        <h3>More Coming Soon</h3>
                    </div>
                </div>
                
                <div class="widget-content" style="display: flex; padding: 15px; justify-content: center; align-items: center; height: 100%;">
                    <div class="coming-soon-message">
                        <span class="coming-soon-icon">🚀</span>
                        <p>Additional dashboards and features will be available in future updates!</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Add this near the top of your JavaScript code, right after the <script> tag
        // Helper function to parse metric values that may be "No Results" or "No Response"
        function parseMetricValue(value) {
            // If it's a number, return it directly
            if (typeof value === 'number') {
                return value;
            }
            
            // If it's a string like "No Results" or "No Response", return 0
            if (typeof value === 'string' && (value.includes('No Results') || value.includes('No Response'))) {
                return 0;
            }
            
            // For null, undefined or other cases, return 0
            return 0;
        }
        // Helper function to determine token source
        function getTokenSource(token) {
            // If the token has a source property, use it
            if (token.source) {
                return token.source;
            }
            
            // Otherwise check if it's in various data sources
            if (currentGraduatedBonkData && currentGraduatedBonkData.some(t => t.token_address === token.token_address)) {
                return 'raydium';
            }
            
            if (currentGraduatedMeteoraData && currentGraduatedMeteoraData.some(t => t.token_address === token.token_address)) {
                return 'meteora';
            }
            
            // Default to PumpFun
            return 'pumpfun';
        }

        // Helper function to get token classifications
        function getTokenClassifications(tokenAddress) {
            if (!currentTokensLlmInterpretationsData || currentTokensLlmInterpretationsData.length === 0) {
                return null;
            }
            
            const tokenData = currentTokensLlmInterpretationsData.find(token => 
                token.token_address === tokenAddress
            );
            
            return tokenData ? tokenData.classifications : null;
        }

        // Helper function to check if token matches classification filters
        function tokenMatchesClassificationFilters(tokenAddress) {
            const classifications = getTokenClassifications(tokenAddress);
            
            // If no classification data exists, include the token by default
            if (!classifications) {
                return true;
            }
            
            // Check each classification against the filter settings
            const checks = [
                !classifications.memecoin || historyShowMemecoin,
                !classifications.utility || historyShowUtility,
                !classifications.ai_token || historyShowAiToken,
                !classifications.tweet_coin || historyShowTweetCoin,
                !classifications.current_event || historyShowCurrentEvent,
                !classifications.racist || historyShowRacist,
                !classifications.offensive || historyShowOffensive,
                !classifications.animals || historyShowAnimals,
                !classifications.political || historyShowPolitical
            ];
            
            // Token passes if it either doesn't have the classification OR the filter is enabled
            return checks.every(check => check === true);
        }



        // Helper function to toggle "Select All" for source filters
        function toggleAllSources(enable) {
            const pumpFunCheckbox = document.getElementById('historyShowPumpFunOnly');
            const raydiumCheckbox = document.getElementById('historyShowRaydiumOnly');
            const meteoraCheckbox = document.getElementById('historyShowMeteoraOnly');
            
            if (pumpFunCheckbox && raydiumCheckbox && meteoraCheckbox) {
                historyShowPumpFunOnly = enable;
                historyShowRaydiumOnly = enable;
                historyShowMeteoraOnly = enable;
                pumpFunCheckbox.checked = enable;
                raydiumCheckbox.checked = enable;
                meteoraCheckbox.checked = enable;
                renderHistoryTokensList(currentHistoryData);
            }
        }

        // Add button to toggle all sources
        function addToggleAllSourcesButton() {
            // This function is now empty to prevent adding duplicate toggle buttons
            console.log('Original addToggleAllSourcesButton function disabled');
        }
        function applySourceFilterChanges() {
            // Add source badge styles
            addSourceBadgeStyles();
            
            // Add source filters to the history widget
            addSourceFilters();
            
            // Add toggle all sources button
            addToggleAllSourcesButton();
            
            // Enhance the filter function with source filtering
            enhanceApplyHistoryFiltersWithSource();
            
            // Mark existing data with PumpFun source
            // Mark existing PumpFun data with source property
            if (currentGraduatedData) {
                currentGraduatedData = currentGraduatedData.map(token => ({
                    ...token,
                    source: token.source || 'pumpfun'
                }));
            }

            if (currentGraduatedLogData) {
                currentGraduatedLogData = currentGraduatedLogData.map(token => ({
                    ...token,
                    source: token.source || 'pumpfun'
                }));
            }

            // Mark existing Raydium data with source property
            if (currentGraduatedBonkData) {
                currentGraduatedBonkData = currentGraduatedBonkData.map(token => ({
                    ...token,
                    source: token.source || 'raydium'
                }));
            }

            if (currentGraduatedBonkLogData) {
                currentGraduatedBonkLogData = currentGraduatedBonkLogData.map(token => ({
                    ...token,
                    source: token.source || 'raydium'
                }));
            }
            
            // Update the display to show source badges
            if (currentHistoryData && currentHistoryData.length > 0) {
                renderHistoryTokensList(currentHistoryData);
            }
            
            console.log('Source filter implementation complete');
        }
        // Replace the complex tryAlternativeGateways with something simpler
        function tryAlternativeGateways(img, originalSrc) {
            // Use a black placeholder directly
            img.classList.add('black-placeholder');
            img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        }

        const graduatedTokensFilePath = 'graduated_tokens_log_current_caps.json';
        const thresholdsFilePath = 'graduated_tokens_thresholds.json';
        const dexPaidFilePath = 'dex_paid_token_log_current_caps.json';
        const dexBoostsFilePath = 'dex_boosts_token_log_current_caps.json';
        const dashboardStatsFilePath = 'dashboard_stats.json';
        const graduatedTokensLogFilePath = 'graduated_tokens_log.json';
        let autoRefreshInterval;
        let lastGraduatedData = [];
        let lastThresholdsData = {};
        let lastDexPaidData = [];
        let lastDexBoostsData = [];
        let lastDashboardStatsData = {};
        let currentGraduatedData = [];
        let currentThresholdsData = {};
        let currentDexPaidData = [];
        let currentDexBoostsData = {};
        let currentDashboardStatsData = {};
        let currentGraduatedLogData = []; // Store the graduated tokens log data
        let tokenThresholdsMap = {}; // Will map token addresses to their threshold data
        let farmRatioChart = null;
        let sortDirection = 'desc'; // 'asc' or 'desc'
        let sortField = 'graduated'; // 'graduated' or 'market-cap'
        let filterSocialLinks = false;
        let excludeFarmTokens = false;

        // Add right after the existing file path variables like graduatedTokensFilePath, thresholdsFilePath, etc.
        const graduatedBonkTokensFilePath = 'graduated_bonk_tokens_log_current_caps.json';
        const bonkThresholdsFilePath = 'graduated_bonk_tokens_thresholds.json';
        const graduatedBonkTokensLogFilePath = 'graduated_bonk_tokens_log.json';

        // Add right after bonkThresholdsFilePath and graduatedBonkTokensLogFilePath
        const graduatedMeteoraTokensFilePath = 'graduated_meteora_tokens_log_current_caps.json';
        const meteoraThresholdsFilePath = 'graduated_meteora_tokens_thresholds.json';
        const graduatedMeteoraTokensLogFilePath = 'graduated_meteora_tokens_log.json';
        const tokensLlmInterpretationsFilePath = 'tokens_llm_interpretations.json';

        // Add right after the existing data storage variables like lastGraduatedData, lastThresholdsData, etc.
        let lastGraduatedBonkData = [];
        let currentGraduatedBonkData = [];
        let lastBonkThresholdsData = {};
        let currentBonkThresholdsData = {};
        let currentGraduatedBonkLogData = [];

        // Add right after currentGraduatedBonkLogData
        let lastGraduatedMeteoraData = [];
        let currentGraduatedMeteoraData = [];
        let lastMeteoraThresholdsData = {};
        let currentMeteoraThresholdsData = {};
        let currentGraduatedMeteoraLogData = [];
        let lastTokensLlmInterpretationsData = [];
        let currentTokensLlmInterpretationsData = [];

        // Add right after the existing filter variables like historyFilterSocialLinks, historyExcludeFarmTokens, etc.
        let historyShowPumpFunOnly = true; // Default to showing PumpFun tokens
        let historyShowRaydiumOnly = true; // Default to showing Raydium tokens
        let historyShowMeteoraOnly = true; // Default to showing Meteora tokens

        // LLM Classification filter variables (all true by default to show all tokens)
        let historyShowMemecoin = true;
        let historyShowUtility = true;
        let historyShowAiToken = true;
        let historyShowTweetCoin = true;
        let historyShowCurrentEvent = true;
        let historyShowRacist = true;
        let historyShowOffensive = true;
        let historyShowAnimals = true;
        let historyShowPolitical = true;

        let selectedLaunchPad = 'combined'; // Default to combined data
        
        // DEX Paid specific sort/filter states
        let dexSortDirection = 'desc';
        let dexSortField = 'timestamp';
        let dexFilterSocialLinks = false;
        let dexExcludeFarmTokens = false;
        
        // DEX Ad Boosts specific sort/filter states
        let boostSortDirection = 'desc';
        let boostSortField = 'timestamp';
        let boostFilterSocialLinks = false;
        let boostExcludeFarmTokens = false;
        
        let historyFilterSocialLinks = false;
        let historyExcludeFarmTokens = false;
        let historySortDirection = 'desc';
        let historySortField = 'timestamp';
        let currentHistoryData = [];
        let showUnfilteredStats = false;

        let historyShowLateBloomerOnly = false;
        let historyShowOldCreationOnly = false;

        let historyThresholdSortDirection = 'desc'; // Direction for threshold sorting
        
        // Global variable to store the threshold sort type
        let thresholdSortType = 'current'; // Default to current market cap

        // Function to add the threshold sort dropdown to the DOM
        function addThresholdSortDropdown() {
            // Create the container
            const container = document.createElement('div');
            container.className = 'threshold-sort-container';
            container.style.display = 'flex';
            container.style.justifyContent = 'flex-end';
            container.style.marginBottom = '10px';
            container.style.marginTop = '20px';
            
            // Create the label
            const label = document.createElement('label');
            label.htmlFor = 'threshold-sort-dropdown';
            label.style.marginRight = '10px';
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            label.textContent = 'Distribute Tokens By:';
            label.style.color = 'var(--text-color)';
            
            // Create the dropdown
            const dropdown = document.createElement('select');
            dropdown.id = 'threshold-sort-dropdown';
            dropdown.className = 'threshold-sort-dropdown';
            dropdown.style.padding = '5px';
            dropdown.style.borderRadius = '4px';
            dropdown.style.backgroundColor = 'var(--widget-bg)';
            dropdown.style.color = 'var(--text-color)';
            dropdown.style.border = '1px solid var(--border-color)';
            
            // Add options
            const options = [
                { value: 'current', text: 'Current Market Cap' },
                { value: 'all_time_high', text: 'All-Time High Market Cap' },
                { value: 'status_high', text: 'Highest Market Cap By Status' }
            ];
            
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                dropdown.appendChild(optionElement);
            });
            
            // Add label and dropdown to container
            container.appendChild(label);
            container.appendChild(dropdown);
            
            // Add container before the all-widgets container
            const allWidgetsContainer = document.getElementById('all-widgets');
            allWidgetsContainer.parentNode.insertBefore(container, allWidgetsContainer);
        }

        // Handle threshold sort dropdown change
        function handleThresholdSortDropdownChange() {
            thresholdSortType = document.getElementById('threshold-sort-dropdown').value;
            
            // Re-organize and re-render all threshold widgets with the new sort type
            renderThresholdWidgets(currentThresholdsData, currentGraduatedData);
        }

        // Function to initialize the threshold sort dropdown
        function updateInitDashboard() {
            // Add the threshold sort dropdown to the DOM
            addThresholdSortDropdown();
            
            // Set up event listener for threshold sort dropdown
            document.getElementById('threshold-sort-dropdown').addEventListener('change', handleThresholdSortDropdownChange);
        }
        // Track filters and sort state for each threshold widget
        let show48HourStats = false; // Default to 24h mode
        let thresholdSettings = {};
        
        // Initialize settings for a threshold
        function initThresholdSettings(threshold) {
            if (!thresholdSettings[threshold]) {
                thresholdSettings[threshold] = {
                    socialLinks: false,
                    excludeFarm: false,
                    sortField: 'timestamp', // 'timestamp' or 'market-cap'
                    sortDirection: 'desc'  // 'asc' or 'desc'
                };
            }
        }
        
        // Define the thresholds we want to display widgets for
        const thresholdsToDisplay = [100000, 250000, 500000, 750000, 1000000];

        // Format currency
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            }).format(value);
        }

        // Format large numbers
        function formatNumber(num) {
            if (num >= 1e12) {
                return (num / 1e12).toFixed(2) + 'T';
            } else if (num >= 1e9) {
                return (num / 1e9).toFixed(2) + 'B';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(2) + 'M';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(2) + 'K';
            }
            return num.toString();
        }
        // Format function for highest threshold
        function formatHighestThreshold(tokenAddress) {
            // Look up the token's threshold data
            const thresholdData = tokenThresholdsMap[tokenAddress];
            
            // If there's no threshold data or no all_time_highest_threshold, return N/A
            if (!thresholdData || thresholdData.all_time_highest_threshold === undefined) {
                return 'N/A';
            }
            
            // Get the highest threshold value
            const highestThreshold = thresholdData.all_time_highest_threshold;
            
            // Format the threshold value
            if (highestThreshold >= 1000000) {
                return `$${(highestThreshold / 1000000).toFixed(2)}M`;
            } else if (highestThreshold >= 1000) {
                return `$${(highestThreshold / 1000).toFixed(0)}K`;
            } else {
                return `$${highestThreshold}`;
            }
        }

        // Format threshold for display
        function formatThreshold(threshold) {
            if (threshold >= 1000000) {
                return `$${(threshold / 1000000).toFixed(2)}M`;
            } else {
                return `$${(threshold / 1000).toFixed(0)}K`;
            }
        }

        // Format timestamp
        function formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            
            const date = new Date(timestamp);
            return date.toLocaleString();
        }

        // Calculate time since graduation in compact format
        function timeSince(timestamp) {
            if (!timestamp) return 'N/A';
            
            const now = new Date();
            const then = new Date(timestamp);
            const diffMs = now - then;
            
            // Convert to seconds, minutes, hours, days
            const seconds = Math.floor(diffMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) {
                const remainingHours = hours % 24;
                return `${days}d${remainingHours > 0 ? remainingHours + 'h' : ''}`;
            } else if (hours > 0) {
                const remainingMinutes = minutes % 60;
                return `${hours}h${remainingMinutes > 0 ? remainingMinutes + 'm' : ''}`;
            } else if (minutes > 0) {
                const remainingSeconds = seconds % 60;
                return `${minutes}m${remainingSeconds > 0 ? remainingSeconds + 's' : ''}`;
            } else {
                return `${seconds}s`;
            }
        }

        // 1. First, modify the formatTimeSince function to accept a second parameter
        function formatTimeSince(timestamp, isDexPaid = false) {
            if (!timestamp) return 'N/A';
            
            // Parse the timestamp - handle different formats
            let date;
            
            try {
                // First try parsing it directly (works for ISO format with T)
                if (timestamp.includes('T')) {
                    date = new Date(timestamp);
                } else {
                    // For YYYY-MM-DD HH:MM:SS format from Python (Pacific time)
                    const parts = timestamp.split(/[- :]/);
                    if (parts.length >= 6) {
                        // Create a date object and adjust for time zone
                        // For PRODUCTION ENV - For Dex Paid entries, ADD 0 hours; for all others, SUBTRACT 7 hours, Otherwise us 0 and 0
                        const hourAdjustment = isDexPaid ? 0 : 0;
                        
                        date = new Date(
                            parseInt(parts[0]),                 // Year
                            parseInt(parts[1]) - 1,             // Month (0-based in JS)
                            parseInt(parts[2]),                 // Day
                            parseInt(parts[3]) + hourAdjustment, // Hours (apply adjustment)
                            parseInt(parts[4]),                 // Minutes
                            parseInt(parts[5])                  // Seconds
                        );
                    } else {
                        // Fallback for unexpected format
                        date = new Date(timestamp);
                    }
                }
            } catch (e) {
                console.error("Error parsing timestamp:", timestamp, e);
                return 'Invalid date';
            }
            
            if (isNaN(date.getTime())) {
                return 'Invalid date';
            }
            
            // Calculate time difference
            const now = new Date();
            const diffMs = now - date;
            
            const seconds = Math.floor(diffMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) {
                const remainingHours = hours % 24;
                return remainingHours > 0 ? `${days}d ${remainingHours}h ago` : `${days}d ago`;
            } else if (hours > 0) {
                const remainingMinutes = minutes % 60;
                return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m ago` : `${hours}h ago`;
            } else if (minutes > 0) {
                return `${minutes}m ago`;
            } else {
                return `${seconds}s ago`;
            }
        }

        // Truncate long text
        function truncate(text, length = 30) {
            if (!text) return 'N/A';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }
        
        // Abbreviate address to show first 3 and last 3 characters
        function abbreviateAddress(address) {
            if (!address) return 'N/A';
            if (address.length <= 8) return address;
            return address.substring(0, 3) + '...' + address.substring(address.length - 4);
        }

        // Copy text to clipboard
        function copyToClipboard(text) {
            // Create a temporary input element
            const input = document.createElement('input');
            input.style.position = 'fixed';
            input.style.opacity = 0;
            input.value = text;
            document.body.appendChild(input);
            
            // Select and copy the text
            input.select();
            document.execCommand('copy');
            
            // Remove the temporary element
            document.body.removeChild(input);
            
            // Show a tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'copy-tooltip';
            tooltip.textContent = 'Copied!';
            tooltip.style.top = event.clientY + 'px';
            tooltip.style.left = event.clientX + 'px';
            document.body.appendChild(tooltip);
            
            // Make the tooltip visible
            setTimeout(() => tooltip.classList.add('visible'), 10);
            
            // Remove the tooltip after a short delay
            setTimeout(() => {
                tooltip.classList.remove('visible');
                setTimeout(() => document.body.removeChild(tooltip), 300);
            }, 1500);
        }

        // Helper function to format percentage values
        function formatPercentage(value) {
            if (value === undefined || value === null) return 'N/A';
            return value.toFixed(1) + '%';
        }

        // Helper function to create metrics HTML
        function createMetricsHTML(token) {
            // Try to get threshold data for this token first
            const thresholdData = tokenThresholdsMap[token.token_address];
            
            if (thresholdData) {
                // Use threshold data if available
                const susValue = thresholdData.current_sus_wallets;
                const devValue = thresholdData.current_dev_holdings;
                const snipeValue = thresholdData.current_insiders;
                
                return `
                    <div class="token-metrics">
                        <span class="metric-tag sus-tag"><span class="full-label">SUS:</span><span class="short-label">S:</span> ${formatPercentage(susValue)}</span>
                        <span class="metric-tag dev-tag"><span class="full-label">DEV:</span><span class="short-label">D:</span> ${formatPercentage(devValue)}</span>
                        <span class="metric-tag insider-tag"><span class="full-label">INSIDER:</span><span class="short-label">I:</span> ${formatPercentage(snipeValue)}</span>
                    </div>
                `;
            } else {
                // Find the token in the graduated tokens log data
                let logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
                
                // If not found in PumpFun log, check in Raydium graduated tokens log
                if (!logToken && currentGraduatedBonkLogData) {
                    logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === token.token_address);
                }

                // If not found in PumpFun or Raydium log, check in Meteora graduated tokens log
                if (!logToken && currentGraduatedMeteoraLogData) {
                    logToken = currentGraduatedMeteoraLogData.find(logToken => logToken.token_address === token.token_address);
                }
                
                if (!logToken) {
                    return ''; // No metrics data available from either source
                }
                
                // Get metrics values from graduated tokens log
                const devValue = parseMetricValue(logToken.dev_holding);
                const snipeValue = parseMetricValue(logToken.insider_wallets);
                
                // For SUS value, take the maximum of bundles, fresh_wallets, holders, or clusters
                const bundles = parseMetricValue(logToken.bundles);
                const freshWallets = parseMetricValue(logToken.fresh_wallets);
                const holders = parseMetricValue(logToken.holders);
                const clusters = parseMetricValue(logToken.clusters);
                
                const susValue = Math.max(bundles, freshWallets, holders, clusters);
                
                return `
                    <div class="token-metrics">
                        <span class="metric-tag sus-tag"><span class="full-label">SUS:</span><span class="short-label">S:</span> ${formatPercentage(susValue)}</span>
                        <span class="metric-tag dev-tag"><span class="full-label">DEV:</span><span class="short-label">D:</span> ${formatPercentage(devValue)}</span>
                        <span class="metric-tag insider-tag"><span class="full-label">INSIDER:</span><span class="short-label">I:</span> ${formatPercentage(snipeValue)}</span>
                    </div>
                `;
            }
        }
// 2. Create a helper function to get the FARM percentage for a token
function getTokenFarmPercentage(token) {
    // First check if we have threshold data for this token
    const thresholdData = tokenThresholdsMap[token.token_address];
    
    // If threshold data exists, prioritize its all_time_sus_wallets value
    if (thresholdData && thresholdData.all_time_sus_wallets !== undefined) {
        return thresholdData.all_time_sus_wallets;
    }
    
    // Fall back to calculating from appropriate token log
    let logToken;
    
    // Check first in PumpFun graduated tokens log
    logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
    
    // If not found in PumpFun log, try Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === token.token_address);
    }

    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(logToken => logToken.token_address === token.token_address);
    }
    
    if (logToken) {
        // Calculate SUS value as the maximum of these metrics
        const bundles = parseMetricValue(logToken.bundles);
        const freshWallets = parseMetricValue(logToken.fresh_wallets);
        const holders = parseMetricValue(logToken.holders);
        const clusters = parseMetricValue(logToken.clusters);
        
        return Math.max(bundles, freshWallets, holders, clusters);
    }
    
    // If no data is available, return 0
    return 0;
}

function getTokenSusPercentage(token) {
    // First check if we have threshold data for this token
    const thresholdData = tokenThresholdsMap[token.token_address];
    
    // If threshold data exists, prioritize its value
    if (thresholdData && thresholdData.current_sus_wallets !== undefined) {
        return thresholdData.current_sus_wallets;
    }
    
    // Fall back to calculating from appropriate token log
    let logToken;
    
    // Check first in PumpFun graduated tokens log
    logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
    
    // If not found in PumpFun log, try Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === token.token_address);
    }

    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(logToken => logToken.token_address === token.token_address);
    }
    
    if (logToken) {
        // For SUS value, parse all metrics and take the maximum
        const bundles = parseMetricValue(logToken.bundles);
        const freshWallets = parseMetricValue(logToken.fresh_wallets);
        const holders = parseMetricValue(logToken.holders);
        const clusters = parseMetricValue(logToken.clusters);
        
        return Math.max(bundles, freshWallets, holders, clusters);
    }
    
    // If no data is available, return 0
    return 0;
}
// Helper function to check if a token has fake distribution
function hasFakeDistribution(tokenAddress) {
    // First check in the thresholds data
    const thresholdData = tokenThresholdsMap[tokenAddress];
    
    if (thresholdData && thresholdData.journey_history && thresholdData.journey_history.length > 0) {
        // Sort the journey history by timestamp (descending) to get the latest entry
        const sortedHistory = [...thresholdData.journey_history].sort((a, b) => {
            // For Dex Paid entries, use dex_paid_timestamp instead of timestamp
            const aTimestamp = a.scan_reason === "Dex Paid" ? a.dex_paid_timestamp : a.timestamp;
            const bTimestamp = b.scan_reason === "Dex Paid" ? b.dex_paid_timestamp : b.timestamp;
            
            // Handle cases where either entry doesn't have the appropriate timestamp
            if (!aTimestamp && !bTimestamp) return 0;
            if (!aTimestamp) return 1; // b is newer
            if (!bTimestamp) return -1; // a is newer
            
            const timeA = new Date(aTimestamp).getTime();
            const timeB = new Date(bTimestamp).getTime();
            return timeB - timeA; // Descending order (newest first)
        });
        
        // Check the latest entry for fake_distribution
        for (const entry of sortedHistory) {
            if (entry.fake_distribution !== undefined) {
                return entry.fake_distribution === true;
            }
        }
    }
    
    // If not found in thresholds data, check in graduated_tokens_log
    const logToken = currentGraduatedLogData.find(token => token.token_address === tokenAddress);
    
    // If found in PumpFun log, return its fake_distribution value
    if (logToken && logToken.fake_distribution !== undefined) {
        return logToken.fake_distribution === true;
    }
    
    // If not found in PumpFun log, check in Raydium graduated tokens log
    if (currentGraduatedBonkLogData) {
        const bonkLogToken = currentGraduatedBonkLogData.find(token => token.token_address === tokenAddress);
        if (bonkLogToken && bonkLogToken.fake_distribution !== undefined) {
            return bonkLogToken.fake_distribution === true;
        }
    }

    // If not found in PumpFun or Raydium log, check in Meteora graduated tokens log
    if (currentGraduatedMeteoraLogData) {
        const meteoraLogToken = currentGraduatedMeteoraLogData.find(token => token.token_address === tokenAddress);
        if (meteoraLogToken && meteoraLogToken.fake_distribution !== undefined) {
            return meteoraLogToken.fake_distribution === true;
        }
    }
    
    // If no data found in any source, default to false
    return false;
}
function getTokenDevPercentage(token) {
    // First check if we have threshold data for this token
    const thresholdData = tokenThresholdsMap[token.token_address];
    
    // If threshold data exists, prioritize its value
    if (thresholdData && thresholdData.current_dev_holdings !== undefined) {
        return thresholdData.current_dev_holdings;
    }
    
    // Fall back to graduated tokens log
    let logToken;
    
    // Check first in PumpFun graduated tokens log
    logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
    
    // If not found in PumpFun log, try Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === token.token_address);
    }
    
    // If not found in Raydium log, try Meteora graduated tokens log
    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(logToken => logToken.token_address === token.token_address);
    }
    
    // AFTER checking all sources, check for a value and return it
    if (logToken && logToken.dev_holding !== undefined) {
        return logToken.dev_holding;
    }
    
    // If no data is available, return 0
    return 0;
}

function getTokenInsiderPercentage(token) {
    // First check if we have threshold data for this token
    const thresholdData = tokenThresholdsMap[token.token_address];
    
    // If threshold data exists, prioritize its value
    if (thresholdData && thresholdData.current_insiders !== undefined) {
        return thresholdData.current_insiders;
    }
    
    // Fall back to graduated tokens log
    let logToken;
    
    // Check first in PumpFun graduated tokens log
    logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
    
    // If not found in PumpFun log, try Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === token.token_address);
    }

    // If not found in Raydium log, try Meteora graduated tokens log
    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(logToken => logToken.token_address === token.token_address);
    }
    
    // Only after checking all sources, check for insider_wallets value
    if (logToken && logToken.insider_wallets !== undefined) {
        return logToken.insider_wallets;
    }
    
    // If no data is available, return 0
    return 0;
}

// Add this function near the top of your JavaScript
function findTokenAcrossAllSources(tokenAddress) {
    // Check first in PumpFun graduated tokens log
    let logToken = currentGraduatedLogData.find(token => token.token_address === tokenAddress);
    
    // If not found in PumpFun log, check in Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(token => token.token_address === tokenAddress);
    }
    
    // If not found in Raydium log, check in Meteora graduated tokens log
    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(token => token.token_address === tokenAddress);
    }
    
    return logToken;
}
// Function to check if a token has an incomplete scan
function hasIncompleteScan(tokenAddress) {
    // First check if we have threshold data
    const thresholdData = tokenThresholdsMap[tokenAddress];
    
    if (thresholdData && thresholdData.journey_history && thresholdData.journey_history.length > 0) {
        // Sort the journey history by timestamp (descending)
        const sortedHistory = [...thresholdData.journey_history].sort((a, b) => {
            // For Dex Paid entries, use dex_paid_timestamp instead of timestamp
            const aTimestamp = a.scan_reason === "Dex Paid" ? a.dex_paid_timestamp : a.timestamp;
            const bTimestamp = b.scan_reason === "Dex Paid" ? b.dex_paid_timestamp : b.timestamp;
            
            // Handle cases where either entry doesn't have the appropriate timestamp
            if (!aTimestamp && !bTimestamp) return 0;
            if (!aTimestamp) return 1; // b is newer
            if (!bTimestamp) return -1; // a is newer
            
            const timeA = new Date(aTimestamp).getTime();
            const timeB = new Date(bTimestamp).getTime();
            return timeB - timeA; // Descending order (newest first)
        });
        
        // Get the latest entry (first in sorted array)
        const latestEntry = sortedHistory[0];
        
        // Check if the latest scan is incomplete - explicitly compare to false
        // This handles cases where is_scan_complete might be undefined
        return latestEntry.is_scan_complete === false;
    }
    
    // If no threshold data, check in PumpFun graduated tokens log
    const logToken = currentGraduatedLogData.find(token => token.token_address === tokenAddress);
    
    // Return true if the token exists in the log and has is_scan_complete set to false
    if (logToken && logToken.is_scan_complete === false) {
        return true;
    }
    
    // If not found in PumpFun log, check in Raydium graduated tokens log
    if (currentGraduatedBonkLogData) {
        const bonkLogToken = currentGraduatedBonkLogData.find(token => token.token_address === tokenAddress);
        if (bonkLogToken && bonkLogToken.is_scan_complete === false) {
            return true;
        }
    }

    if (currentGraduatedMeteoraLogData) {
        const meteoraLogToken = currentGraduatedMeteoraLogData.find(token => token.token_address === tokenAddress);
        if (meteoraLogToken && meteoraLogToken.is_scan_complete === false) {
            return true;
        }
    }
    
    // If no relevant data found in any source, return false (assume scan is complete)
    return false;
}

// Helper function to create farm label with percentage
// Update the createFarmLabelHTML function to handle "No Results"
function createFarmLabelHTML(token, forceFarm = false) {
    // Get token address
    const tokenAddress = token.token_address;
    
    // Check if this token has fake distribution
    const hasFakeDistrib = hasFakeDistribution(tokenAddress);
    
    // Try to get threshold data for this token first
    const thresholdData = tokenThresholdsMap[tokenAddress];
    
    // If threshold data exists, prioritize its farm_status
    if (thresholdData) {
        const farmStatus = thresholdData.farm_status;
        const percentage = thresholdData.all_time_sus_wallets || 0;
        const percentageText = ` ${formatPercentage(percentage)}`;
        
        if (farmStatus === "FARM") {
            // Set the color based on fake distribution status for FARM tags
            const farmLabelColor = hasFakeDistrib ? '#8B008B' : 'var(--farm-label-bg)'; // Magenta if fake distribution, else red
            return `<span class="farm-label" style="background-color: ${farmLabelColor};">FARM${percentageText}</span>`;
        } else if (farmStatus === "FARMED") {
            // Yellow color for FARMED tags
            return `<span class="instafarmed-label">FARMED${percentageText}</span>`;
        } else if (farmStatus === "NO_FARM") {
            // Green color for NO FARM DETECTED tags
            return `<span class="no-farm-label">NO FARM</span>`;
        }
    }
    
    // Fall back to original logic if no threshold data or no farm status in threshold data
    const isFarm = forceFarm || (token.meets_filter_criteria === false);
    
    if (!isFarm && token.farm_status !== "FARMED") {
        // This case means it's not a farm - add NO FARM DETECTED tag with green color
        return `<span class="no-farm-label">NO FARM</span>`;
    }
    
    // Calculate percentage from logs for fallback
    let percentage = null;
    let logToken = currentGraduatedLogData.find(logToken => logToken.token_address === tokenAddress);
    
    // If not found in PumpFun log, check in Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(logToken => logToken.token_address === tokenAddress);
    }
    
    if (logToken) {
        // Calculate SUS value as the maximum of these metrics
        const bundles = parseMetricValue(logToken.bundles);
        const freshWallets = parseMetricValue(logToken.fresh_wallets);
        const holders = parseMetricValue(logToken.holders);
        const clusters = parseMetricValue(logToken.clusters);
        
        percentage = Math.max(bundles, freshWallets, holders, clusters);
    }
    
    const percentageText = percentage !== null ? ` ${formatPercentage(percentage)}` : '';
    
    if (isFarm) {
        // Set the color based on fake distribution status for FARM tags
        const farmLabelColor = hasFakeDistrib ? '#8B008B' : 'var(--farm-label-bg)'; // Magenta if fake distribution, else red
        return `<span class="farm-label" style="background-color: ${farmLabelColor};">FARM${percentageText}</span>`;
    } else if (token.farm_status === "FARMED") {
        // Yellow color for FARMED tags
        return `<span class="instafarmed-label">FARMED${percentageText}</span>`;
    }
    
    return ''; // No farm status detected
}


// Check if token has any social links
function hasSocialLinks(token) {
    return token.website || token.twitter || token.telegram;
}

// Create token row for graduated tokens widget
function createGraduatedTokenRow(token) {
    const row = document.createElement('div');
    row.className = 'token-row';
    
    // Add a data attribute to track if it has social links
    row.dataset.hasSocialLinks = hasSocialLinks(token) ? 'true' : 'false';
    
    // Check if we have threshold data
    const thresholdData = tokenThresholdsMap[token.token_address];
    
    // Add farm-token class ONLY if it's a FARM token (not a FARMED token)
    if (thresholdData) {
        // If we have threshold data, only add the class if farm_status is "FARM"
        if (thresholdData.farm_status === "FARM") {
            row.classList.add('farm-token');
        }
    } else {
        // Fallback to the original logic if no threshold data
        if (token.meets_filter_criteria === false && token.farm_status !== "FARMED") {
            row.classList.add('farm-token');
        }
    }
    
    // Default image if none provided
    const imageUrl = token.image_uri || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    
    // Get the updated farm label HTML
    const farmLabelHTML = createFarmLabelHTML(token);
    
    // Create metrics HTML but don't include in the token info section
    const metricsHTML = createMetricsHTML(token);
    
    // Create token link URL
    const tokenUrl = `https://dexscreener.com/solana/${token.token_address}`;
    
    row.innerHTML = `
        <div class="token-image-container">
            <img src="${imageUrl}" alt="${token.name}" class="token-image" onerror="tryAlternativeGateways(this, this.src)">
            <div class="graduation-time" title="Time since graduation">${timeSince(token.timestamp)}</div>
        </div>
        
        <div class="token-details-container">
            <div class="token-info-container">
                <h3 class="token-name">
                    <a href="${tokenUrl}" class="token-name-link" target="_blank">${token.name || 'Unknown Token'}</a>
                </h3>
            </div>
            <div class="token-info">
                <div class="token-details">
                    <p class="token-symbol">${token.symbol || 'N/A'}</p>
                    <span class="abbreviated-address" title="${token.token_address}">${abbreviateAddress(token.token_address)}</span>
                    <span class="copy-icon" title="Copy token address" data-address="${token.token_address}">📋</span>
                </div>
                <div class="token-social">
                    ${token.website ? `<a class="token-link" href="${token.website}" target="_blank" title="Website">🌐</a>` : ''}
                    ${token.twitter ? `<a class="token-link" href="${token.twitter}" target="_blank" title="Twitter">🐦</a>` : ''}
                    ${token.telegram ? `<a class="token-link" href="${token.telegram}" target="_blank" title="Telegram">📱</a>` : ''}
                </div>
            </div>
        </div>
        
        <div class="marketcap-col">
            ${farmLabelHTML ? `<div style="text-align: center; margin-bottom: 4px;">${farmLabelHTML}</div>` : ''}
            <div class="marketcap-value">${formatCurrency(token.usd_market_cap || 0)}</div>
            <div class="marketcap-label">Market Cap</div>
        </div>
        
        <div class="token-metrics-container">
            ${metricsHTML}
        </div>
    `;
    
    // Add event listener to copy icon
    const copyIcon = row.querySelector('.copy-icon');
    if (copyIcon) {
        copyIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            const address = this.getAttribute('data-address');
            copyToClipboard(address);
        });
    }
    
    return row;
}

// Create token row for DEX paid widget
function createDexPaidTokenRow(token) {
    const row = document.createElement('div');
    row.className = 'token-row';
    
    // Add a data attribute to track if it has social links
    row.dataset.hasSocialLinks = hasSocialLinks(token) ? 'true' : 'false';
    
    // Add farm-token class if meets_filter_criteria is false
    if (token.meets_filter_criteria === false) {
        row.classList.add('farm-token');
    }
    
    // Add nsfw data attribute
    row.dataset.nsfw = token.nsfw ? 'true' : 'false';
    
    // Default image if none provided
    const imageUrl = token.image_uri || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    
    // Get the updated farm label HTML
    const farmLabelHTML = createFarmLabelHTML(token);
    
    // Show NSFW badge if needed
    const nsfwBadgeHTML = token.nsfw ? '<span class="nsfw-badge">NSFW</span>' : '';
    
    // Create metrics HTML but don't include in the token info section
    const metricsHTML = createMetricsHTML(token);
    
    // Create token link URL
    const tokenUrl = `https://pump.fun/coin/${token.token_address}`;
    
    row.innerHTML = `
        <div class="token-image-container">
            <img src="${imageUrl}" alt="${token.name}" class="token-image" onerror="tryAlternativeGateways(this, this.src)">
            <div class="graduation-time" title="Time since added">${timeSince(token.timestamp)}</div>
        </div>
        
        <div class="token-details-container">
            <div class="token-info-container">
                <h3 class="token-name">
                    <a href="${tokenUrl}" class="token-name-link" target="_blank">${token.name || 'Unknown Token'}</a>
                </h3>
                ${nsfwBadgeHTML}
            </div>
            <div class="token-info">
                <div class="token-details">
                    <p class="token-symbol">${token.symbol || 'N/A'}</p>
                    <span class="abbreviated-address" title="${token.token_address}">${abbreviateAddress(token.token_address)}</span>
                    <span class="copy-icon" title="Copy token address" data-address="${token.token_address}">📋</span>
                </div>
                <div class="token-social">
                    ${token.website ? `<a class="token-link" href="${token.website}" target="_blank" title="Website">🌐</a>` : ''}
                    ${token.twitter ? `<a class="token-link" href="${token.twitter}" target="_blank" title="Twitter">🐦</a>` : ''}
                    ${token.telegram ? `<a class="token-link" href="${token.telegram}" target="_blank" title="Telegram">📱</a>` : ''}
                </div>
            </div>
        </div>
        
        <div class="marketcap-col">
            ${farmLabelHTML ? `<div style="text-align: center; margin-bottom: 4px;">${farmLabelHTML}</div>` : ''}
            <div class="marketcap-value">${formatCurrency(token.usd_market_cap || 0)}</div>
            <div class="marketcap-label">Market Cap</div>
        </div>
        
        <div class="token-metrics-container">
            ${metricsHTML}
        </div>
    `;
    
    // Add event listener to copy icon
    const copyIcon = row.querySelector('.copy-icon');
    if (copyIcon) {
        copyIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            const address = this.getAttribute('data-address');
            copyToClipboard(address);
        });
    }
    // Check if this token has an incomplete scan
    const isIncomplete = hasIncompleteScan(token.token_address);

    if (isIncomplete) {
        // Remove farm-token class if it exists
        row.classList.remove('farm-token');
        
        // Add incomplete-scan-token class
        row.classList.add('incomplete-scan-token');
        
    }
    return row;
}

// Create token row for DEX boost widget
function createDexBoostTokenRow(token) {
    const row = document.createElement('div');
    row.className = 'token-row-with-boost';
    
    // Add a data attribute to track if it has social links
    row.dataset.hasSocialLinks = hasSocialLinks(token) ? 'true' : 'false';
    
    // Add farm-token class if meets_filter_criteria is false
    if (token.meets_filter_criteria === false) {
        row.classList.add('farm-token');
    }
    
    // Add nsfw data attribute
    row.dataset.nsfw = token.nsfw ? 'true' : 'false';
    
    // Default image if none provided
    const imageUrl = token.image_uri || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    
    // Get the updated farm label HTML
    const farmLabelHTML = createFarmLabelHTML(token);
    
    // Show NSFW badge if needed
    const nsfwBadgeHTML = token.nsfw ? '<span class="nsfw-badge">NSFW</span>' : '';
    
    // Determine boost badge class
    let boostBadgeClass = 'boost-low';
    if (token.boost_amount >= 100) {
        boostBadgeClass = 'boost-high';
    } else if (token.boost_amount >= 30) {
        boostBadgeClass = 'boost-medium';
    }
    
    // Create metrics HTML but don't include in the token info section
    const metricsHTML = createMetricsHTML(token);
    
    // Create token link URL
    const tokenUrl = `https://pump.fun/coin/${token.token_address}`;
    
    row.innerHTML = `
        <div class="token-image-container">
            <img src="${imageUrl}" alt="${token.name}" class="token-image" onerror="tryAlternativeGateways(this, this.src)">
            <div class="graduation-time" title="Time since added">${timeSince(token.timestamp)}</div>
        </div>
        
        <div class="token-details-container">
            <div class="token-info-container">
                <h3 class="token-name">
                    <a href="${tokenUrl}" class="token-name-link" target="_blank">${token.name || 'Unknown Token'}</a>
                </h3>
                ${nsfwBadgeHTML}
                <span class="boost-badge ${boostBadgeClass}">Boost ${token.boost_amount}/${token.total_boost_amount}</span>
            </div>
            <div class="token-info">
                <div class="token-details">
                    <p class="token-symbol">${token.symbol || 'N/A'}</p>
                    <span class="abbreviated-address" title="${token.token_address}">${abbreviateAddress(token.token_address)}</span>
                    <span class="copy-icon" title="Copy token address" data-address="${token.token_address}">📋</span>
                </div>
                <div class="token-social">
                    ${token.website ? `<a class="token-link" href="${token.website}" target="_blank" title="Website">🌐</a>` : ''}
                    ${token.twitter ? `<a class="token-link" href="${token.twitter}" target="_blank" title="Twitter">🐦</a>` : ''}
                    ${token.telegram ? `<a class="token-link" href="${token.telegram}" target="_blank" title="Telegram">📱</a>` : ''}
                </div>
            </div>
        </div>
        
        <div class="marketcap-col">
            ${farmLabelHTML ? `<div style="text-align: center; margin-bottom: 4px;">${farmLabelHTML}</div>` : ''}
            <div class="marketcap-value">${formatCurrency(token.usd_market_cap || 0)}</div>
            <div class="marketcap-label">Market Cap</div>
        </div>
        
        <div class="token-metrics-container">
            ${metricsHTML}
        </div>
    `;
    
    // Add event listener to copy icon
    const copyIcon = row.querySelector('.copy-icon');
    if (copyIcon) {
        copyIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            const address = this.getAttribute('data-address');
            copyToClipboard(address);
        });
    }
    // Check if this token has an incomplete scan
    const isIncomplete = hasIncompleteScan(token.token_address);

    if (isIncomplete) {
        // Remove farm-token class if it exists
        row.classList.remove('farm-token');
        
        // Add incomplete-scan-token class
        row.classList.add('incomplete-scan-token');
        
    }
    return row;
}

// Create token row for threshold widget
function createThresholdTokenRow(token, tokenAddress, thresholdInfo) {
    const row = document.createElement('div');
    row.className = 'token-row';
    
    // Get farm status and apply styling
    const farmStatus = thresholdInfo.farm_status;
    
    // Add farm-token class for FARM status
    if (farmStatus === "FARM") {
        row.classList.add('farm-token');
    }
    
    // Default image if none provided
    const imageUrl = token.image_uri || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    
    // Determine farm label with percentage
    let farmLabelHTML = '';
    if (farmStatus === "FARM") {
        const percentage = thresholdInfo.all_time_sus_wallets || 0;
        farmLabelHTML = `<span class="farm-label">FARM ${formatPercentage(percentage)}</span>`;
    } else if (farmStatus === "FARMED") {
        const percentage = thresholdInfo.all_time_sus_wallets || 0;
        farmLabelHTML = `<span class="instafarmed-label">FARMED ${formatPercentage(percentage)}</span>`;
    }
    
    // Create metrics HTML directly from thresholdInfo
    const metricsHTML = `
        <div class="token-metrics">
            <span class="metric-tag sus-tag">SUS: ${formatPercentage(thresholdInfo.current_sus_wallets)}</span>
            <span class="metric-tag dev-tag">DEV: ${formatPercentage(thresholdInfo.current_dev_holdings)}</span>
            <span class="metric-tag insider-tag">INSIDER: ${formatPercentage(thresholdInfo.current_insiders)}</span>
        </div>
    `;
    
    // Create token link URL
    const tokenUrl = `https://pump.fun/coin/${tokenAddress}`;
    
    row.innerHTML = `
        <div class="token-image-container">
            <img src="${imageUrl}" alt="${token.name}" class="token-image" onerror="tryAlternativeGateways(this, this.src)">
            <div class="graduation-time" title="Time since threshold reached">${timeSince(thresholdInfo.original_timestamp)}</div>
        </div>
        
        <div class="token-details-container">
            <div class="token-info-container">
                <h3 class="token-name">
                    <a href="${tokenUrl}" class="token-name-link" target="_blank">${token.name || 'Unknown Token'}</a>
                </h3>
            </div>
            <div class="token-info">
                <div class="token-details">
                    <p class="token-symbol">${token.symbol || 'N/A'}</p>
                    <span class="abbreviated-address" title="${tokenAddress}">${abbreviateAddress(tokenAddress)}</span>
                    <span class="copy-icon" title="Copy token address" data-address="${tokenAddress}">📋</span>
                </div>
                <div class="token-social">
                    ${token.website ? `<a class="token-link" href="${token.website}" target="_blank" title="Website">🌐</a>` : ''}
                    ${token.twitter ? `<a class="token-link" href="${token.twitter}" target="_blank" title="Twitter">🐦</a>` : ''}
                    ${token.telegram ? `<a class="token-link" href="${token.telegram}" target="_blank" title="Telegram">📱</a>` : ''}
                </div>
            </div>
        </div>
        
        <div class="marketcap-col">
            ${farmLabelHTML ? `<div style="text-align: center; margin-bottom: 4px;">${farmLabelHTML}</div>` : ''}
            <div class="marketcap-value">${formatCurrency(token.usd_market_cap || 0)}</div>
            <div class="marketcap-label">Market Cap</div>
        </div>
        
        <div class="token-metrics-container">
            ${metricsHTML}
        </div>
    `;
    
    // Add event listener to copy icon
    const copyIcon = row.querySelector('.copy-icon');
    if (copyIcon) {
        copyIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            const address = this.getAttribute('data-address');
            copyToClipboard(address);
        });
    }
    // Check if this token has an incomplete scan
    const isIncomplete = hasIncompleteScan(tokenAddress);

    if (isIncomplete) {
        // Remove farm-token class if it exists
        row.classList.remove('farm-token');
        
        // Add incomplete-scan-token class
        row.classList.add('incomplete-scan-token');
        
    }
    return row;
}

// Sort data by field
function sortData(data, field, direction = 'desc') {
    // If sorting by threshold, use custom sort
    if (field === 'threshold') {
        return [...data].sort((a, b) => {
            let valueA = 0;
            let valueB = 0;
            
            // Get threshold values from tokenThresholdsMap
            if (tokenThresholdsMap[a.token_address] && 
                tokenThresholdsMap[a.token_address].all_time_highest_threshold !== undefined) {
                valueA = tokenThresholdsMap[a.token_address].all_time_highest_threshold;
            }
            
            if (tokenThresholdsMap[b.token_address] && 
                tokenThresholdsMap[b.token_address].all_time_highest_threshold !== undefined) {
                valueB = tokenThresholdsMap[b.token_address].all_time_highest_threshold;
            }
            
            // Apply sort direction
            return direction === 'asc' 
                ? valueA - valueB 
                : valueB - valueA;
        });
    }
    
    // Create a new array instead of sorting in place
    return [...data].sort((a, b) => {
        let valueA, valueB;
        
        if (field === 'market-cap') {
            valueA = a.usd_market_cap || 0;
            valueB = b.usd_market_cap || 0;
        } else if (field === 'boost-amount') {
            valueA = a.boost_amount || 0;
            valueB = b.boost_amount || 0;
        } else if (field === 'graduated' || field === 'timestamp') {
            valueA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            valueB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
        }
        
        return direction === 'asc' 
            ? valueA - valueB 
            : valueB - valueA;
    });
}

// Apply filters to data
function applyFilters(data) {
    let filteredData = [...data];
    
    // Filter by social links
    if (filterSocialLinks) {
        filteredData = filteredData.filter(token => hasSocialLinks(token));
    }
    
    // Filter out farm tokens
    if (excludeFarmTokens) {
        filteredData = filteredData.filter(token => token.meets_filter_criteria !== false);
    }
    
    return filteredData;
}

// Apply filters to DEX paid data
function applyDexPaidFilters(data) {
    let filteredData = [...data];
    
    // Filter by social links
    if (dexFilterSocialLinks) {
        filteredData = filteredData.filter(token => hasSocialLinks(token));
    }
    
    // Filter out farm tokens
    if (dexExcludeFarmTokens) {
        filteredData = filteredData.filter(token => token.meets_filter_criteria !== false);
    }
    
    return filteredData;
}

// Apply filters to DEX boost data
function applyDexBoostFilters(data) {
    let filteredData = [...data];
    
    // Filter by social links
    if (boostFilterSocialLinks) {
        filteredData = filteredData.filter(token => hasSocialLinks(token));
    }
    
    // Filter out farm tokens
    if (boostExcludeFarmTokens) {
        filteredData = filteredData.filter(token => token.meets_filter_criteria !== false);
    }
    
    return filteredData;
}

// Handle threshold sort
function handleThresholdSort(threshold, field, tokens, container, graduatedTokens) {
    const settings = thresholdSettings[threshold];
    
    // If clicking the same field, toggle direction; otherwise set to desc
    if (settings.sortField === field) {
        settings.sortDirection = settings.sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        settings.sortField = field;
        settings.sortDirection = 'desc';
    }
    
    // Update sort indicator
    const widget = document.getElementById(`threshold-widget-${threshold}`);
    updateSortIndicator(threshold, widget);
    
    // Re-render tokens list
    renderThresholdTokensList(threshold, tokens, container, graduatedTokens);
}

// Update sort indicator
function updateSortIndicator(threshold, widget) {
    const settings = thresholdSettings[threshold];
    
    // Reset all sort indicators
    widget.querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    // Update active sort indicator
    if (settings.sortField === 'market-cap') {
        const sortElement = widget.querySelector(`#sort-market-cap-${threshold}`);
        if (sortElement) {
            sortElement.classList.add(settings.sortDirection);
        }
    } else if (settings.sortField === 'timestamp') {
        const sortElement = widget.querySelector(`#sort-timestamp-${threshold}`);
        if (sortElement) {
            sortElement.classList.add(settings.sortDirection);
        }
    }
}

// Render graduated tokens list
function renderGraduatedTokensList(data) {
    // Apply filters
    let filteredData = applyFilters(data);
    
    // Clear tokens list
    const tokensList = document.getElementById('tokens-list');
    tokensList.innerHTML = '';
    
    if (filteredData.length === 0) {
        tokensList.innerHTML = '<div class="empty-state">No tokens found matching your filters</div>';
        return;
    }
    
    // Create and append token rows
    filteredData.forEach(token => {
        const row = createGraduatedTokenRow(token);
        tokensList.appendChild(row);
    });
}

// Render DEX paid tokens list
function renderDexPaidTokensList(data) {
    // Apply filters
    let filteredData = applyDexPaidFilters(data);
    
    // Clear tokens list
    const tokensList = document.getElementById('dex-tokens-list');
    tokensList.innerHTML = '';
    
    if (filteredData.length === 0) {
        tokensList.innerHTML = '<div class="empty-state">No tokens found matching your filters</div>';
        return;
    }
    
    // Create and append token rows
    filteredData.forEach(token => {
        const row = createDexPaidTokenRow(token);
        tokensList.appendChild(row);
    });
}

// Render DEX boost tokens list
function renderDexBoostTokensList(data) {
    // Apply filters
    let filteredData = applyDexBoostFilters(data);
    
    // Clear tokens list
    const tokensList = document.getElementById('boost-tokens-list');
    tokensList.innerHTML = '';
    
    if (filteredData.length === 0) {
        tokensList.innerHTML = '<div class="empty-state">No tokens found matching your filters</div>';
        return;
    }
    
    // Create and append token rows
    filteredData.forEach(token => {
        const row = createDexBoostTokenRow(token);
        tokensList.appendChild(row);
    });
}

// Create a threshold widget
function createThresholdWidget(threshold, tokens, graduatedTokens) {
    // Initialize settings for this threshold
    initThresholdSettings(threshold);
    
    const widget = document.createElement('div');
    widget.className = 'widget';
    widget.id = `threshold-widget-${threshold}`;
    
    // Format threshold for display
    const formattedThreshold = formatThreshold(threshold);
    
    // Create widget header container
    const widgetHeaderContainer = document.createElement('div');
    widgetHeaderContainer.className = 'widget-header-container';
    
    // Create widget header
    const widgetHeader = document.createElement('div');
    widgetHeader.className = 'widget-header';
    widgetHeader.innerHTML = `
        <h3><span class="threshold-amount">${formattedThreshold}</span> Threshold</h3>
        <div class="filter-controls">
            <div class="filter-control">
                <input type="checkbox" id="hasSocialLinks-${threshold}" name="hasSocialLinks-${threshold}">
                <label for="hasSocialLinks-${threshold}">Socials</label>
            </div>
            <div class="filter-control">
                <input type="checkbox" id="excludeFarmTokens-${threshold}" name="excludeFarmTokens-${threshold}">
                <label for="excludeFarmTokens-${threshold}">No FARMS</label>
            </div>
        </div>
    `;
    
    // Create token header
    const tokenHeader = document.createElement('div');
    tokenHeader.className = 'token-header';
    tokenHeader.innerHTML = `
        <div class="sortable" id="sort-timestamp-${threshold}"></div>
        <div>Token</div>
        <div class="marketcap-col sortable" id="sort-market-cap-${threshold}">MC</div>
    `;
    
    // Add header components to header container
    widgetHeaderContainer.appendChild(widgetHeader);
    widgetHeaderContainer.appendChild(tokenHeader);
    
    // Create tokens list container
    const tokenListContainer = document.createElement('div');
    tokenListContainer.className = 'token-list-container';
    
    // Create tokens list
    const tokensList = document.createElement('div');
    tokensList.id = `threshold-${threshold}-tokens-list`;
    tokensList.className = 'threshold-tokens-list';
    
    // Add tokens list to its container
    tokenListContainer.appendChild(tokensList);
    
    // Add everything to the widget
    widget.appendChild(widgetHeaderContainer);
    widget.appendChild(tokenListContainer);
    
    // Add event listeners for filters
    const socialLinksCheckbox = widget.querySelector(`#hasSocialLinks-${threshold}`);
    const excludeFarmCheckbox = widget.querySelector(`#excludeFarmTokens-${threshold}`);
    
    socialLinksCheckbox.addEventListener('change', function(e) {
        thresholdSettings[threshold].socialLinks = e.target.checked;
        renderThresholdTokensList(threshold, tokens, tokensList, graduatedTokens);
    });
    
    excludeFarmCheckbox.addEventListener('change', function(e) {
        thresholdSettings[threshold].excludeFarm = e.target.checked;
        renderThresholdTokensList(threshold, tokens, tokensList, graduatedTokens);
    });
    
    // Set initial checkbox states
    socialLinksCheckbox.checked = thresholdSettings[threshold].socialLinks;
    excludeFarmCheckbox.checked = thresholdSettings[threshold].excludeFarm;
    
    // Add event listener for market cap sorting
    const marketCapSort = widget.querySelector(`#sort-market-cap-${threshold}`);
    marketCapSort.addEventListener('click', function() {
        handleThresholdSort(threshold, 'market-cap', tokens, tokensList, graduatedTokens);
    });
    
    // Add event listener for timestamp sorting
    const timestampSort = widget.querySelector(`#sort-timestamp-${threshold}`);
    timestampSort.addEventListener('click', function() {
        handleThresholdSort(threshold, 'timestamp', tokens, tokensList, graduatedTokens);
    });
    
    // Set initial sort indicator
    updateSortIndicator(threshold, widget);
    
    // Set initial visual state for timestamp sorter
    const timestampSorter = widget.querySelector(`#sort-timestamp-${threshold}`);
    if (timestampSorter) {
        timestampSorter.classList.add('desc');
    }
    
    // Render the token rows
    renderThresholdTokensList(threshold, tokens, tokensList, graduatedTokens);
    
    return widget;
}

// Apply filters to threshold tokens
function applyThresholdFilters(threshold, tokens, graduatedTokens) {
    const settings = thresholdSettings[threshold];
    
    // Start with all tokens
    let filteredTokens = [...Object.entries(tokens)];
    
    // Apply social links filter if enabled
    if (settings.socialLinks) {
        filteredTokens = filteredTokens.filter(([tokenAddress, _]) => {
            // Find matching token in graduated tokens to check for social links
            const matchingToken = graduatedTokens.find(token => token.token_address === tokenAddress);
            return matchingToken && hasSocialLinks(matchingToken);
        });
    }
    
    // Apply exclude farm filter if enabled
    if (settings.excludeFarm) {
        filteredTokens = filteredTokens.filter(([_, thresholdInfo]) => {
            return thresholdInfo.farm_status !== "FARM";
        });
    }
    
    return filteredTokens;
}

// Sort threshold tokens
function sortThresholdTokens(threshold, tokens, graduatedTokens) {
    const settings = thresholdSettings[threshold];
    
    return tokens.sort((a, b) => {
        let valueA, valueB;
        
        // Determine which values to compare based on sort field
        if (settings.sortField === 'market-cap') {
            // Find matching tokens in graduated tokens data to get market cap
            const tokenA = graduatedTokens.find(token => token.token_address === a[0]) || {};
            const tokenB = graduatedTokens.find(token => token.token_address === b[0]) || {};
            
            valueA = tokenA.usd_market_cap || 0;
            valueB = tokenB.usd_market_cap || 0;
        } else {
            // Sort by timestamp (default)
            valueA = new Date(a[1].original_timestamp || 0).getTime();
            valueB = new Date(b[1].original_timestamp || 0).getTime();
        }
        
        // Apply sort direction
        return settings.sortDirection === 'asc' 
            ? valueA - valueB 
            : valueB - valueA;
    });
}

// Render tokens for a threshold widget
function renderThresholdTokensList(threshold, tokens, container, graduatedTokens) {
    if (!tokens || Object.keys(tokens).length === 0) {
        container.innerHTML = '<div class="empty-state">No tokens have reached this threshold yet</div>';
        return;
    }
    
    // Apply filters
    const filteredTokens = applyThresholdFilters(threshold, tokens, graduatedTokens);
    
    if (filteredTokens.length === 0) {
        container.innerHTML = '<div class="empty-state">No tokens match the current filters</div>';
        return;
    }
    
    // Sort tokens
    const sortedTokens = sortThresholdTokens(threshold, filteredTokens, graduatedTokens);
    
    // Clear container
    container.innerHTML = '';
    
    // Create and append token rows
    sortedTokens.forEach(([tokenAddress, thresholdInfo]) => {
        // Find matching token in graduated tokens data to get additional info
        const matchingToken = graduatedTokens.find(token => token.token_address === tokenAddress) || {};
        
        const row = createThresholdTokenRow(matchingToken, tokenAddress, thresholdInfo);
        container.appendChild(row);
    });
}

// Modified organizeTokensByThreshold function to use the global sort type
function organizeTokensByThreshold(thresholdsData, graduatedTokens) {
    // Reset the thresholdTokens object
    const thresholdTokens = {};
    
    // Initialize threshold buckets
    thresholdsToDisplay.forEach(threshold => {
        thresholdTokens[threshold] = {};
    });
    
    // For each token in thresholdsData
    Object.entries(thresholdsData).forEach(([tokenAddress, thresholdInfo]) => {
        let targetThreshold = 0;
        
        if (thresholdSortType === 'current') {
            // Get current market cap from graduatedTokens (including merged Raydium tokens)
            const token = graduatedTokens.find(t => t.token_address === tokenAddress);
            if (token && token.usd_market_cap) {
                // Find the appropriate threshold bucket for this market cap
                for (let i = thresholdsToDisplay.length - 1; i >= 0; i--) {
                    if (token.usd_market_cap >= thresholdsToDisplay[i]) {
                        targetThreshold = thresholdsToDisplay[i];
                        break;
                    }
                }
            }
        } else if (thresholdSortType === 'all_time_high') {
            // Use all_time_highest_threshold
            const allTimeHigh = thresholdInfo.all_time_highest_threshold || 0;
            
            // Find the appropriate threshold bucket
            for (let i = thresholdsToDisplay.length - 1; i >= 0; i--) {
                if (allTimeHigh >= thresholdsToDisplay[i]) {
                    targetThreshold = thresholdsToDisplay[i];
                    break;
                }
            }
        } else if (thresholdSortType === 'status_high') {
            // Use highest_threshold
            targetThreshold = thresholdInfo.highest_threshold || 0;
            
            // Only include if it's one of our display thresholds
            if (!thresholdsToDisplay.includes(targetThreshold)) {
                targetThreshold = 0; // Won't be displayed
            }
        }
        
        // Add token to the appropriate threshold bucket if it belongs in any
        if (targetThreshold > 0 && thresholdsToDisplay.includes(targetThreshold)) {
            thresholdTokens[targetThreshold][tokenAddress] = thresholdInfo;
        }
    });
    
    return thresholdTokens;
}
// Modified version of renderThresholdWidgets to preserve scroll position
function renderThresholdWidgets(thresholdsData, graduatedTokens) {
    // Organize tokens by threshold
    const tokensByThreshold = organizeTokensByThreshold(thresholdsData, graduatedTokens);
    
    // Get the container
    const container = document.getElementById('all-widgets');
    
    // Save scroll positions of existing threshold widgets before updating
    const scrollPositions = {};
    document.querySelectorAll('.threshold-widget').forEach(widget => {
        const threshold = widget.id.replace('threshold-widget-', '');
        const tokenContainer = widget.querySelector('.token-list-container');
        if (tokenContainer) {
            scrollPositions[threshold] = tokenContainer.scrollTop;
        }
    });
    
    // Check if widgets already exist
    let widgetsExist = document.querySelectorAll('.threshold-widget').length > 0;
    
    if (!widgetsExist) {
        // First time rendering - create all widgets
        thresholdsToDisplay.forEach(threshold => {
            const widget = createThresholdWidget(threshold, tokensByThreshold[threshold], graduatedTokens);
            widget.classList.add('threshold-widget'); // Add class for identification
            container.appendChild(widget);
        });
    } else {
        // Widgets already exist - just update their content
        thresholdsToDisplay.forEach(threshold => {
            // Update the existing widget content
            const tokensListContainer = document.querySelector(`#threshold-${threshold}-tokens-list`);
            if (tokensListContainer) {
                renderThresholdTokensList(threshold, tokensByThreshold[threshold], tokensListContainer, graduatedTokens);
            }
        });
        
        // Restore scroll positions
        setTimeout(() => {
            Object.keys(scrollPositions).forEach(threshold => {
                const tokenContainer = document.querySelector(`#threshold-widget-${threshold} .token-list-container`);
                if (tokenContainer) {
                    tokenContainer.scrollTop = scrollPositions[threshold];
                }
            });
        }, 0);
    }
}

// Fetch and process graduated tokens data
async function fetchGraduatedTokensData() {
    try {
        const response = await fetch(graduatedTokensFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated tokens data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastGraduatedData)) {
            console.log('Graduated tokens data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastGraduatedData = data;
        
        // Sort tokens by the current sort field and direction
        currentGraduatedData = sortData(data, sortField, sortDirection);
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated tokens data:', error);
        document.getElementById('tokens-list').innerHTML = `
            <div class="empty-state">
                <p>Error loading graduated tokens data: ${error.message}</p>
                <p>Make sure the JSON file '${graduatedTokensFilePath}' is available.</p>
            </div>
        `;
        return false;
    }
}

// Fetch and process DEX paid data
async function fetchDexPaidData() {
    try {
        const response = await fetch(dexPaidFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch DEX paid data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastDexPaidData)) {
            console.log('DEX paid data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastDexPaidData = data;
        
        // Sort tokens using current sort settings
        currentDexPaidData = sortData(data, dexSortField, dexSortDirection);
        
        return true;
        
    } catch (error) {
        console.error('Error fetching DEX paid data:', error);
        document.getElementById('dex-tokens-list').innerHTML = `
            <div class="empty-state">
                <p>Error loading DEX paid data: ${error.message}</p>
                <p>Make sure the JSON file '${dexPaidFilePath}' is available.</p>
            </div>
        `;
        return false;
    }
}

// Fetch and process DEX boost data
async function fetchDexBoostData() {
    try {
        const response = await fetch(dexBoostsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch DEX boost data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastDexBoostsData)) {
            console.log('DEX boost data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastDexBoostsData = data;
        
        // Sort tokens using current sort settings
        currentDexBoostsData = sortData(data, boostSortField, boostSortDirection);
        
        return true;
        
    } catch (error) {
        console.error('Error fetching DEX boost data:', error);
        document.getElementById('boost-tokens-list').innerHTML = `
            <div class="empty-state">
                <p>Error loading DEX boost data: ${error.message}</p>
                <p>Make sure the JSON file '${dexBoostsFilePath}' is available.</p>
            </div>
        `;
        return false;
    }
}

// Fetch and process thresholds data
async function fetchThresholdsData() {
    try {
        const response = await fetch(thresholdsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch thresholds data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastThresholdsData)) {
            console.log('Thresholds data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastThresholdsData = data;
        currentThresholdsData = data;
        
        // Create a map of token addresses to threshold data for easy lookup
        tokenThresholdsMap = {};
        Object.entries(data).forEach(([tokenAddress, thresholdInfo]) => {
            tokenThresholdsMap[tokenAddress] = thresholdInfo;
        });
        
        return true;
        
    } catch (error) {
        console.error('Error fetching thresholds data:', error);
        document.getElementById('threshold-widgets').innerHTML = `
            <div class="empty-state">
                <p>Error loading thresholds data: ${error.message}</p>
                <p>Make sure the JSON file '${thresholdsFilePath}' is available.</p>
            </div>
        `;
        return false;
    }
}

// Add right after fetchGraduatedTokensLogData() function
// Fetch and process graduated Bonk tokens data
async function fetchGraduatedBonkTokensData() {
    try {
        const response = await fetch(graduatedBonkTokensFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated Bonk tokens data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastGraduatedBonkData)) {
            console.log('Graduated Bonk tokens data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastGraduatedBonkData = data;
        
        // Add source info to each token
        const processedData = data.map(token => {
            // Start with existing token data if available
            const existingToken = currentGraduatedBonkData ?
                currentGraduatedBonkData.find(t => t.token_address === token.token_address) : null;
            
            // Merge with new data
            return {
                ...(existingToken || {}), // Keep existing data if available
                ...token, // Update with new data
                source: 'raydium' // Ensure source is set
            };
        });
        
        // Save processed data
        currentGraduatedBonkData = processedData;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated Bonk tokens data:', error);
        return false;
    }
}
// Fetch and process Bonk thresholds data
async function fetchBonkThresholdsData() {
    try {
        const response = await fetch(bonkThresholdsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch Bonk thresholds data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastBonkThresholdsData)) {
            console.log('Bonk thresholds data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastBonkThresholdsData = data;
        currentBonkThresholdsData = data;
        
        // Add source property to each threshold entry
        Object.entries(data).forEach(([tokenAddress, thresholdInfo]) => {
            // Add a source property to the threshold data
            data[tokenAddress] = {
                ...thresholdInfo,
                source: 'raydium'
            };
            
            // Update the tokenThresholdsMap with this entry
            tokenThresholdsMap[tokenAddress] = data[tokenAddress];
        });
        
        return true;
        
    } catch (error) {
        console.error('Error fetching Bonk thresholds data:', error);
        return false;
    }
}

// Function to fetch the graduated Bonk tokens log data
async function fetchGraduatedBonkTokensLogData() {
    try {
        const response = await fetch(graduatedBonkTokensLogFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated Bonk tokens log data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Add source info to each token
        const processedData = data.map(token => ({
            ...token,
            source: 'raydium'
        }));
        
        currentGraduatedBonkLogData = processedData;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated Bonk tokens log data:', error);
        return false;
    }
}

// Fetch and process graduated Meteora tokens data
async function fetchGraduatedMeteoraTokensData() {
    try {
        const response = await fetch(graduatedMeteoraTokensFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated Meteora tokens data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastGraduatedMeteoraData)) {
            console.log('Graduated Meteora tokens data unchanged, no update needed');
            return false;
        }
        
        // Add some console logging to verify the data structure
        console.log('Meteora data loaded, sample token:', data.length > 0 ? data[0] : 'No tokens found');
        
        // Save the new data
        lastGraduatedMeteoraData = data;
        
        // Add source info to each token
        const processedData = data.map(token => {
            // Start with existing token data if available
            const existingToken = currentGraduatedMeteoraData ?
                currentGraduatedMeteoraData.find(t => t.token_address === token.token_address) : null;
            
            // Merge with new data
            return {
                ...(existingToken || {}), // Keep existing data if available
                ...token, // Update with new data
                source: 'meteora' // Ensure source is set
            };
        });
        
        // Save processed data
        currentGraduatedMeteoraData = processedData;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated Meteora tokens data:', error);
        return false;
    }
}

// Fetch and process Meteora thresholds data
// Fetch and process Meteora thresholds data
async function fetchMeteoraThresholdsData() {
    try {
        const response = await fetch(meteoraThresholdsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch Meteora thresholds data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastMeteoraThresholdsData)) {
            console.log('Meteora thresholds data unchanged, no update needed');
            return false;
        }
        
        // Add logging to verify data
        console.log('Meteora threshold data loaded, number of entries:', Object.keys(data).length);
        if (Object.keys(data).length > 0) {
            console.log('Sample Meteora threshold entry:', data[Object.keys(data)[0]]);
        }
        
        // Save the new data
        lastMeteoraThresholdsData = data;
        currentMeteoraThresholdsData = data;
        
        // Add source property to each threshold entry
        Object.entries(data).forEach(([tokenAddress, thresholdInfo]) => {
            // Add a source property to the threshold data
            data[tokenAddress] = {
                ...thresholdInfo,
                source: 'meteora'
            };
            
            // Update the tokenThresholdsMap with this entry
            tokenThresholdsMap[tokenAddress] = data[tokenAddress];
        });
        
        return true;
        
    } catch (error) {
        console.error('Error fetching Meteora thresholds data:', error);
        return false;
    }
}

// Function to fetch the graduated Meteora tokens log data
async function fetchGraduatedMeteoraTokensLogData() {
    try {
        const response = await fetch(graduatedMeteoraTokensLogFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated Meteora tokens log data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Add source info to each token
        const processedData = data.map(token => ({
            ...token,
            source: 'meteora'
        }));
        
        currentGraduatedMeteoraLogData = processedData;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated Meteora tokens log data:', error);
        return false;
    }
}

// Function to fetch the tokens LLM interpretations data
async function fetchTokensLlmInterpretationsData() {
    try {
        const response = await fetch(tokensLlmInterpretationsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch tokens LLM interpretations data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastTokensLlmInterpretationsData)) {
            console.log('Tokens LLM interpretations data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastTokensLlmInterpretationsData = data;
        currentTokensLlmInterpretationsData = data;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching tokens LLM interpretations data:', error);
        return false;
    }
}

// Fetch and process dashboard stats data
async function fetchDashboardStatsData() {
    try {
        const response = await fetch(dashboardStatsFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch dashboard stats data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Check if data has changed
        if (JSON.stringify(data) === JSON.stringify(lastDashboardStatsData)) {
            console.log('Dashboard stats data unchanged, no update needed');
            return false;
        }
        
        // Save the new data
        lastDashboardStatsData = data;
        currentDashboardStatsData = data;
        
        return true;
        
    } catch (error) {
        console.error('Error fetching dashboard stats data:', error);
        return false;
    }
}

// Function to fetch the graduated tokens log data
async function fetchGraduatedTokensLogData() {
    try {
        const response = await fetch(graduatedTokensLogFilePath + '?t=' + new Date().getTime());
        if (!response.ok) {
            throw new Error(`Failed to fetch graduated tokens log data: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        currentGraduatedLogData = data;
        
        // Create a map for faster lookup
        currentGraduatedLogData.forEach(token => {
            // Add the token to a lookup map by address if needed
        });
        
        return true;
        
    } catch (error) {
        console.error('Error fetching graduated tokens log data:', error);
        return false;
    }
}

// Modified version of fetchData to avoid recreating threshold widgets unnecessarily
// Modified version of fetchData to avoid recreating threshold widgets unnecessarily
async function fetchData() {
    try {
        // Fetch PumpFun, Raydium, and Meteora token data
        const [
            graduatedChanged,
            thresholdsChanged,
            // dexPaidChanged,
            // dexBoostChanged,
            statsChanged,
            graduatedLogFetched,
            graduatedBonkChanged,
            bonkThresholdsChanged,
            graduatedBonkLogFetched,
            graduatedMeteoraChanged,
            meteoraThresholdsChanged,
            graduatedMeteoraLogFetched,
            llmInterpretationsChanged
        ] = await Promise.all([
            fetchGraduatedTokensData(),
            fetchThresholdsData(),
            // fetchDexPaidData(),
            // fetchDexBoostData(),
            fetchDashboardStatsData(),
            fetchGraduatedTokensLogData(),
            fetchGraduatedBonkTokensData(),
            fetchBonkThresholdsData(),
            fetchGraduatedBonkTokensLogData(),
            fetchGraduatedMeteoraTokensData(),
            fetchMeteoraThresholdsData(),
            fetchGraduatedMeteoraTokensLogData(),
            fetchTokensLlmInterpretationsData()
        ]);
        
        // Update last updated time
        document.getElementById('last-updated').textContent = new Date().toLocaleString();
        
        // Flag to track if we need to update the history view
        const needsHistoryUpdate = graduatedChanged || thresholdsChanged || graduatedLogFetched || 
                          graduatedBonkChanged || bonkThresholdsChanged || graduatedBonkLogFetched ||
                          graduatedMeteoraChanged || meteoraThresholdsChanged || graduatedMeteoraLogFetched ||
                          llmInterpretationsChanged;
        
        // If any data sets changed, update without recreating widgets
        if (needsHistoryUpdate) {
            // Mark existing data with source if not already set
            currentGraduatedData = currentGraduatedData.map(token => ({
                ...token,
                source: token.source || 'pumpfun'
            }));
            
            // Create a deep merged map of all threshold datasets for consistency
            let mergedThresholds = {};
            
            // Add PumpFun threshold data
            if (currentThresholdsData) {
                Object.entries(currentThresholdsData).forEach(([tokenAddress, thresholdInfo]) => {
                    mergedThresholds[tokenAddress] = thresholdInfo;
                });
            }
            
            // Add Raydium threshold data
            if (currentBonkThresholdsData) {
                Object.entries(currentBonkThresholdsData).forEach(([tokenAddress, thresholdInfo]) => {
                    mergedThresholds[tokenAddress] = thresholdInfo;
                });
            }
            
            // Add Meteora threshold data
            if (currentMeteoraThresholdsData) {
                Object.entries(currentMeteoraThresholdsData).forEach(([tokenAddress, thresholdInfo]) => {
                    mergedThresholds[tokenAddress] = thresholdInfo;
                });
            }
            
            // Update global tokenThresholdsMap with complete merged data
            tokenThresholdsMap = mergedThresholds;
            
            // Merge PumpFun, Raydium, and Meteora token data for the graduated widget
            const mergedGraduatedData = [...currentGraduatedData];
            
            // Add Raydium tokens if they exist and aren't already included
            if (currentGraduatedBonkData && currentGraduatedBonkData.length > 0) {
                currentGraduatedBonkData.forEach(bonkToken => {
                    // Ensure token has source property
                    bonkToken.source = 'raydium';
                    
                    // Check if this token is already in the merged data
                    const existingTokenIndex = mergedGraduatedData.findIndex(token => 
                        token.token_address === bonkToken.token_address);
                    
                    if (existingTokenIndex === -1) {
                        // Token doesn't exist, add it
                        mergedGraduatedData.push(bonkToken);
                    } else {
                        // Token exists but might need updated market cap
                        // Only update market cap but preserve other data
                        mergedGraduatedData[existingTokenIndex] = mergeTokenData(mergedGraduatedData[existingTokenIndex], bonkToken);
                    }
                });
            }
            
            // Add Meteora tokens if they exist and aren't already included
            if (currentGraduatedMeteoraData && currentGraduatedMeteoraData.length > 0) {
                currentGraduatedMeteoraData.forEach(meteoraToken => {
                    // Ensure token has source property
                    meteoraToken.source = 'meteora';
                    
                    // Check if this token is already in the merged data
                    const existingTokenIndex = mergedGraduatedData.findIndex(token => 
                        token.token_address === meteoraToken.token_address);
                    
                    if (existingTokenIndex === -1) {
                        // Token doesn't exist, add it
                        mergedGraduatedData.push(meteoraToken);
                    } else {
                        // Token exists but might need updated market cap
                        // Only update market cap but preserve other data
                        mergedGraduatedData[existingTokenIndex] = mergeTokenData(mergedGraduatedData[existingTokenIndex], meteoraToken);
                    }
                });
            }
            
            // Render graduated tokens list with merged data
            renderGraduatedTokensList(mergedGraduatedData);
            
            // Render threshold widgets with merged data
            renderThresholdWidgets(mergedThresholds, mergedGraduatedData);
            
            // Create a deep copy of the merged data for history
            currentHistoryData = JSON.parse(JSON.stringify(mergedGraduatedData));
            
            // Sort the history data using its own sort settings
            currentHistoryData = sortData(currentHistoryData, historySortField, historySortDirection);
            
            // Then render with the history's sorted data
            renderHistoryTokensList(currentHistoryData);
        }
        
        // If DEX paid data changed, re-render that widget
        // if (dexPaidChanged) {
        //     renderDexPaidTokensList(currentDexPaidData);
        // }
        
        // If DEX boost data changed, re-render that widget
        // if (dexBoostChanged) {
        //     renderDexBoostTokensList(currentDexBoostsData);
        // }
        
        // If dashboard stats changed, update the stats widget and farm ratio chart
        if (statsChanged) {
            updateStatsWidget(currentDashboardStatsData);
            updateFarmRatioChart(currentDashboardStatsData);
        }
        
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}


// Initialize auto-refresh with fixed 5-second interval
function initAutoRefresh() {
    // Set a fixed 5-second refresh interval
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = setInterval(fetchData, 5000);
}

// Handle sorting
function handleSort(field) {
    // Reset only graduated widget sort indicators
    document.getElementById('graduated-widget').querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    const sortElement = document.getElementById(`sort-${field}`);
    
    // If clicking the same field, toggle direction; otherwise set to desc
    if (sortField === field) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        sortField = field;
        sortDirection = 'desc';
    }
    
    // Update sort indicator
    sortElement.classList.add(sortDirection);
    
    // Sort data - create a new sorted array
    currentGraduatedData = sortData(currentGraduatedData, sortField, sortDirection);
    
    // Re-render graduated tokens list
    renderGraduatedTokensList(currentGraduatedData);
}

// Handle DEX paid sorting
function handleDexSort(field) {
    // Reset all sort indicators in the DEX paid widget
    document.getElementById('dex-paid-widget').querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    const sortElement = document.getElementById(`sort-dex-${field}`);
    
    // If clicking the same field, toggle direction; otherwise set to desc
    if (dexSortField === field) {
        dexSortDirection = dexSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        dexSortField = field;
        dexSortDirection = 'desc';
    }
    
    // Update sort indicator
    sortElement.classList.add(dexSortDirection);
    
    // Sort data
    currentDexPaidData = sortData(currentDexPaidData, dexSortField, dexSortDirection);
    
    // Re-render DEX paid tokens list
    renderDexPaidTokensList(currentDexPaidData);
}

// Handle DEX boost sorting
function handleBoostSort(field) {
    // Reset all sort indicators in the DEX boost widget
    document.getElementById('dex-boosts-widget').querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    const sortElement = document.getElementById(`sort-boost-${field}`);
    
    // If clicking the same field, toggle direction; otherwise set to desc
    if (boostSortField === field) {
        boostSortDirection = boostSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        boostSortField = field;
        boostSortDirection = 'desc';
    }
    
    // Update sort indicator
    sortElement.classList.add(boostSortDirection);
    
    // Sort data
    currentDexBoostsData = sortData(currentDexBoostsData, boostSortField, boostSortDirection);
    
    // Re-render DEX boost tokens list
    renderDexBoostTokensList(currentDexBoostsData);
}

// Handle market cap sort
function handleMarketCapSort() {
    handleSort('market-cap');
}

// Handle graduated sort
function handleGraduatedSort() {
    handleSort('graduated');
}

// Handle DEX market cap sort
function handleDexMarketCapSort() {
    handleDexSort('market-cap');
}

// Handle DEX timestamp sort
function handleDexTimestampSort() {
    handleDexSort('timestamp');
}

// Handle boost market cap sort
function handleBoostMarketCapSort() {
    handleBoostSort('market-cap');
}

// Handle boost timestamp sort
function handleBoostTimestampSort() {
    handleBoostSort('timestamp');
}

// Handle boost amount sort
function handleBoostAmountSort() {
    handleBoostSort('boost-amount');
}

// Handle social links filter change
function handleSocialLinksFilterChange(event) {
    filterSocialLinks = event.target.checked;
    renderGraduatedTokensList(currentGraduatedData);
}

// Handle exclude farm tokens filter change
function handleExcludeFarmTokensChange(event) {
    excludeFarmTokens = event.target.checked;
    renderGraduatedTokensList(currentGraduatedData);
}

// Handle DEX social links filter change
function handleDexSocialLinksFilterChange(event) {
    dexFilterSocialLinks = event.target.checked;
    renderDexPaidTokensList(currentDexPaidData);
}

// Handle DEX exclude farm tokens filter change
function handleDexExcludeFarmTokensChange(event) {
    dexExcludeFarmTokens = event.target.checked;
    renderDexPaidTokensList(currentDexPaidData);
}

// Handle boost social links filter change
function handleBoostSocialLinksFilterChange(event) {
    boostFilterSocialLinks = event.target.checked;
    renderDexBoostTokensList(currentDexBoostsData);
}

// Handle boost exclude farm tokens filter change
function handleBoostExcludeFarmTokensChange(event) {
    boostExcludeFarmTokens = event.target.checked;
    renderDexBoostTokensList(currentDexBoostsData);
}

// Initialize dark mode based on user preference
// Always use dark mode
function initDarkMode() {
    // Always apply dark mode to body
    document.body.classList.add('dark-mode');
    
    // Store the preference in local storage
    localStorage.setItem('theme', 'dark');
    
    // No need for event listeners since there's no toggle
}

// Create and initialize the farm ratio chart
// Create and initialize the farm ratio chart
function initStatsChart() {
    const farmRatioCtx = document.getElementById('farmRatioChart').getContext('2d');
    
    // Create farm vs non-farm ratio chart
    farmRatioChart = new Chart(farmRatioCtx, {
        type: 'pie',
        data: {
            labels: [
                'Farm Tokens',
                'Non-Farm Tokens'
            ],
            datasets: [{
                data: [0, 0],
                backgroundColor: [
                    getComputedStyle(document.documentElement).getPropertyValue('--chart-farm-color'),
                    getComputedStyle(document.documentElement).getPropertyValue('--chart-250k-color')
                ],
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-color')
                    }
                },
                title: {
                    display: true,
                    text: 'Farm vs Non-Farm Ratio (24h)', // Default to 24h
                    color: getComputedStyle(document.documentElement).getPropertyValue('--header-color'),
                    font: {
                        size: 16
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.raw || 0;
                            const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                            const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
                            return `${label}: ${value} (${percentage}%)`;
                        }
                    }
                },
                datalabels: {
                    formatter: (value, ctx) => {
                        const total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                        const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
                        return percentage + '%';
                    },
                    color: '#fff',
                    font: {
                        weight: 'bold',
                        size: 14
                    }
                }
            }
        },
        plugins: [ChartDataLabels]
    });
}

// Update the farm ratio chart with new data
// Update the farm ratio chart with new data
// Update the farm ratio chart with new data
function updateFarmRatioChart(data) {
    if (!farmRatioChart) return;
    
    // Determine which time period to use
    const timePeriod = show48HourStats ? '48h' : '24h';
    
    // Get the data for the selected launch pad
    const launchPadData = data[selectedLaunchPad] || data.combined;
    
    // Update farm vs non-farm ratio chart with the appropriate time period data
    const farmTotal = launchPadData[`farm_tokens_${timePeriod}`];
    const nonFarmTotal = launchPadData[`non_farm_filtered_${timePeriod}`];
    
    farmRatioChart.data.datasets[0].data = [
        farmTotal,
        nonFarmTotal
    ];
    
    farmRatioChart.update();
}
// Function to update the Farm Ratio chart title based on time period
// Function to update the Farm Ratio chart title based on time period and selected launch pad
function updateFarmRatioChartTitle() {
    if (!farmRatioChart) return;
    
    // Get the launch pad name for the title
    let launchPadName;
    switch (selectedLaunchPad) {
        case 'pumpfun':
            launchPadName = 'PumpFun';
            break;
        case 'raydium':
            launchPadName = 'Raydium';
            break;
        default:
            launchPadName = 'Combined';
    }
    
    // Update the title text to reflect the current time period and launch pad
    const titleText = show48HourStats ? 
        `${launchPadName} Farm Ratio (48h)` : 
        `${launchPadName} Farm Ratio (24h)`;
    
    farmRatioChart.options.plugins.title.text = titleText;
    farmRatioChart.update();
}

// Update the stats widgets with the dashboard stats data
// Update the stats widgets with the dashboard stats data
// Update the stats widgets with the dashboard stats data
function updateStatsWidget(data) {
    // Update last updated time for both widgets
    const lastUpdated = new Date(data.last_updated);
    document.getElementById('stats-last-updated').textContent = lastUpdated.toLocaleString();
    document.getElementById('threshold-stats-last-updated').textContent = lastUpdated.toLocaleString();
    
    // Determine which time period to use
    const timePeriod = show48HourStats ? '48h' : '24h';
    
    // Get the data for the selected launch pad
    const launchPadData = data[selectedLaunchPad] || data.combined;
    
    // Update stats values with the appropriate time period
    document.getElementById('stats-total-graduated').textContent = launchPadData[`graduated_tokens_${timePeriod}`];
    document.getElementById('stats-farm-tokens').textContent = launchPadData[`farm_tokens_${timePeriod}`];
    document.getElementById('stats-non-farm-tokens').textContent = launchPadData[`non_farm_filtered_${timePeriod}`];
    
    // Update threshold stats based on toggle state and filtered status
    if (showUnfilteredStats) {
        // Show total (unfiltered) values
        document.getElementById('stats-100k').textContent = launchPadData[`threshold_100k_total_${timePeriod}`];
        document.getElementById('stats-250k').textContent = launchPadData[`threshold_250k_total_${timePeriod}`];
        document.getElementById('stats-500k').textContent = launchPadData[`threshold_500k_total_${timePeriod}`];
        document.getElementById('stats-750k').textContent = launchPadData[`threshold_750k_total_${timePeriod}`];
        document.getElementById('stats-1m').textContent = launchPadData[`threshold_1m_total_${timePeriod}`];
    } else {
        // Show filtered values (default behavior)
        document.getElementById('stats-100k').textContent = launchPadData[`threshold_100k_filtered_${timePeriod}`];
        document.getElementById('stats-250k').textContent = launchPadData[`threshold_250k_filtered_${timePeriod}`];
        document.getElementById('stats-500k').textContent = launchPadData[`threshold_500k_filtered_${timePeriod}`];
        document.getElementById('stats-750k').textContent = launchPadData[`threshold_750k_filtered_${timePeriod}`];
        document.getElementById('stats-1m').textContent = launchPadData[`threshold_1m_filtered_${timePeriod}`];
    }
}
        
// Apply filters to history data
function applyHistoryFilters(data) {
    let filteredData = [...data];
    
    // Filter by social links
    if (historyFilterSocialLinks) {
        filteredData = filteredData.filter(token => hasSocialLinks(token));
    }
    
    // Filter out farm tokens but keep FARMED tokens
    if (historyExcludeFarmTokens) {
        filteredData = filteredData.filter(token => {
            // First check if we have threshold data
            const thresholdData = tokenThresholdsMap[token.token_address];
            
            if (thresholdData) {
                // Using threshold data: exclude only if farm_status is "FARM"
                // Keep the token if farm_status is "FARMED" or anything else
                return thresholdData.farm_status !== "FARM";
            }
            
            // Fallback: if no threshold data, check default properties
            // Keep if meets_filter_criteria isn't false OR if it's explicitly FARMED
            return token.meets_filter_criteria !== false || token.farm_status === "FARMED";
        });
    }

    // Apply Late Bloomer filter if enabled
    if (historyShowLateBloomerOnly) {
        filteredData = filteredData.filter(token => {
            // Find matching token in graduated tokens log
            const logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
            // Include only tokens where is_late_bloomer is true
            return logToken && logToken.is_late_bloomer === true;
        });
    }

    // Apply Old Creation filter if enabled
    if (historyShowOldCreationOnly) {
        filteredData = filteredData.filter(token => {
            // Find matching token in graduated tokens log
            const logToken = currentGraduatedLogData.find(logToken => logToken.token_address === token.token_address);
            // Include only tokens where is_old_creation is true
            return logToken && logToken.is_old_creation === true;
        });
    }
    
    return filteredData;
}

// Handle history sort
function handleHistorySort(field) {
    // Reset only history widget sort indicators
    document.getElementById('history-widget').querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    const sortElement = document.getElementById(`sort-history-${field}`);
    
    // If clicking the same field, toggle direction; otherwise set to desc
    if (historySortField === field) {
        historySortDirection = historySortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        historySortField = field;
        historySortDirection = 'desc';
    }
    
    // Update sort indicator
    sortElement.classList.add(historySortDirection);
    
    // Sort data - create a new sorted array rather than modifying in place
    currentHistoryData = sortData(currentHistoryData, historySortField, historySortDirection);
    
    // Re-render history tokens list
    renderHistoryTokensList(currentHistoryData);
}

// Render history tokens list
function renderHistoryTokensList(data) {
    // Apply filters
    let filteredData = applyHistoryFilters(data);
    
    // Clear tokens list
    const tokensList = document.getElementById('history-tokens-list');
    tokensList.innerHTML = '';
    
    if (filteredData.length === 0) {
        tokensList.innerHTML = '<div class="empty-state">No tokens found matching your filters</div>';
        return;
    }
    
    // Create and append token rows
    filteredData.forEach(token => {
        const row = createGraduatedTokenRow(token);
        tokensList.appendChild(row);
    });
}

// Handle history market cap sort
function handleHistoryMarketCapSort() {
    handleHistorySort('market-cap');
}

// Handle history timestamp sort
function handleHistoryTimestampSort() {
    handleHistorySort('timestamp');
}

// Handle history social links filter change
function handleHistorySocialLinksFilterChange(event) {
    historyFilterSocialLinks = event.target.checked;
    renderHistoryTokensList(currentHistoryData);
}

// Handle history exclude farm tokens filter change
function handleHistoryExcludeFarmTokensChange(event) {
    historyExcludeFarmTokens = event.target.checked;
    renderHistoryTokensList(currentHistoryData);
}

function handleHistoryThresholdSort() {
    // Reset all sort indicators in the history widget
    document.getElementById('history-widget').querySelectorAll('.sortable').forEach(el => {
        el.classList.remove('asc', 'desc');
    });
    
    const sortElement = document.getElementById('sort-history-threshold');
    
    // Toggle sort direction
    historyThresholdSortDirection = historyThresholdSortDirection === 'asc' ? 'desc' : 'asc';
    
    // Update sort indicator
    sortElement.classList.add(historyThresholdSortDirection);
    
    // Set global variables
    historySortField = 'threshold';
    historySortDirection = historyThresholdSortDirection;
    
    // Custom sort function for highest threshold
    const sortedData = [...currentHistoryData].sort((a, b) => {
        let valueA = 0;
        let valueB = 0;
        
        // Get threshold values from tokenThresholdsMap
        if (tokenThresholdsMap[a.token_address] && 
            tokenThresholdsMap[a.token_address].all_time_highest_threshold !== undefined) {
            valueA = tokenThresholdsMap[a.token_address].all_time_highest_threshold;
        }
        
        if (tokenThresholdsMap[b.token_address] && 
            tokenThresholdsMap[b.token_address].all_time_highest_threshold !== undefined) {
            valueB = tokenThresholdsMap[b.token_address].all_time_highest_threshold;
        }
        
        // Apply sort direction
        return historyThresholdSortDirection === 'asc' 
            ? valueA - valueB 
            : valueB - valueA;
    });
    
    // Update global current data with the sorted data
    currentHistoryData = sortedData;
    
    // Re-render history tokens list
    renderHistoryTokensList(currentHistoryData);
}

        // Initialize dashboard
        async function initDashboard() {
            await fetchData();
            initAutoRefresh();
            initDarkMode();
            
            // Add this line:
            updateInitDashboard();
            
            // Set up event listeners for graduated widget
            document.getElementById('sort-market-cap').addEventListener('click', handleMarketCapSort);
            document.getElementById('sort-graduated').addEventListener('click', handleGraduatedSort);
            document.getElementById('hasSocialLinks').addEventListener('change', handleSocialLinksFilterChange);
            document.getElementById('excludeFarmTokens').addEventListener('change', handleExcludeFarmTokensChange);
            
            // Set up event listeners for DEX paid widget
            document.getElementById('sort-dex-market-cap').addEventListener('click', handleDexMarketCapSort);
            document.getElementById('sort-dex-timestamp').addEventListener('click', handleDexTimestampSort);
            document.getElementById('dexHasSocialLinks').addEventListener('change', handleDexSocialLinksFilterChange);
            document.getElementById('dexExcludeFarmTokens').addEventListener('change', handleDexExcludeFarmTokensChange);
            
            // Set up event listeners for DEX boost widget
            document.getElementById('sort-boost-market-cap').addEventListener('click', handleBoostMarketCapSort);
            document.getElementById('sort-boost-timestamp').addEventListener('click', handleBoostTimestampSort);
            document.getElementById('boostHasSocialLinks').addEventListener('change', handleBoostSocialLinksFilterChange);
            document.getElementById('boostExcludeFarmTokens').addEventListener('change', handleBoostExcludeFarmTokensChange);
            
            // Add initial sort indicators
            document.getElementById('sort-graduated').classList.add(sortDirection);
            document.getElementById('sort-dex-timestamp').classList.add(dexSortDirection);
            document.getElementById('sort-boost-timestamp').classList.add(boostSortDirection);
            
            // Set up event listeners for history widget
            document.getElementById('sort-history-market-cap').addEventListener('click', handleHistoryMarketCapSort);
            document.getElementById('sort-history-timestamp').addEventListener('click', handleHistoryTimestampSort);
            document.getElementById('historyHasSocialLinks').addEventListener('change', handleHistorySocialLinksFilterChange);
            document.getElementById('historyExcludeFarmTokens').addEventListener('change', handleHistoryExcludeFarmTokensChange);
            
            // Add initial sort indicator for history widget
            document.getElementById('sort-history-timestamp').classList.add(historySortDirection);
            
            // Initialize the stats chart
            initStatsChart();
            addLaunchPadSelector();
        }

        // Function to add the updated CSS to the page
        function addUpdatedCSS() {
            // This function is intentionally left empty as the CSS is already included in the style section
            // The updated token row structure CSS is already part of the main stylesheet
        }

        // Add CSS for the farm status tag
        function addFarmStatusStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .history-farm-status {
                    display: inline-block;
                    padding: 2px 5px;
                    border-radius: 3px;
                    font-size: 0.65rem;
                    font-weight: bold;
                    margin-top: 2px;
                    margin-bottom: 2px;
                    white-space: nowrap;
                }
                
                /* Adjust vertical spacing between elements in history item */
                .history-item {
                    display: flex;
                    flex-direction: column;
                    margin-right: 8px;
                    margin-bottom: 0px;
                }
                
                /* Make the timestamp stay close to the farm status tag */
                .history-timestamp {
                    font-size: 0.6rem;
                    color: var(--subtext-color);
                    margin-top: 2px;
                    margin-left: 2px;
                    white-space: nowrap;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // Add some CSS for the ellipsis tag
        function addEllipsisStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .history-item .history-tag:contains('Rescanning...') {
                    padding: 2px 10px;
                    font-weight: bold;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // 1. Add CSS for the Dex Paid tag
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .dex-paid-tag {
                display: inline-block;
                background-color: var(--badge-bg);
                color: var(--badge-color);
                padding: 1px 5px;
                border-radius: 3px;
                font-size: 0.65rem;
                margin-left: 5px;
                font-weight: bold;
                transition: background-color 0.3s ease, color 0.3s ease;
            }
        `;
        document.head.appendChild(styleElement);

        // 2. Helper function to check if a token has "dex_paid" field set to true
        function isDexPaid(tokenAddress) {
            // First check in the thresholds data
            const thresholdData = tokenThresholdsMap[tokenAddress];
            if (thresholdData && thresholdData.dex_paid === true) {
                return true;
            }
            
            // If not found or not DEX paid in thresholds data, check in graduated_tokens_log
            const logToken = currentGraduatedLogData.find(token => token.token_address === tokenAddress);
            return logToken && logToken.dex_paid === true;
        }

        // 3. Function to create Dex Paid tag HTML
        function createDexPaidTagHTML(tokenAddress) {
            if (isDexPaid(tokenAddress)) {
                return '<span class="dex-paid-tag">DEX PAID</span>';
            }
            return '';
        }

        // 4. Modify createGraduatedTokenRow function - add Dex Paid tag
        const originalCreateGraduatedTokenRow = createGraduatedTokenRow;
        createGraduatedTokenRow = function(token) {
            const row = originalCreateGraduatedTokenRow(token);
            
            // Add the Dex Paid tag next to social links if applicable
            if (isDexPaid(token.token_address)) {
                const socialDiv = row.querySelector('.token-social');
                if (socialDiv) {
                    const dexPaidTag = document.createElement('span');
                    dexPaidTag.className = 'dex-paid-tag';
                    dexPaidTag.textContent = 'DEX PAID';
                    socialDiv.appendChild(dexPaidTag);
                }
            }
            const isIncomplete = hasIncompleteScan(token.token_address);

            if (isIncomplete) {
                // Remove farm-token class if it exists
                row.classList.remove('farm-token');
                
                // Add incomplete-scan-token class
                row.classList.add('incomplete-scan-token');
                
            }
            return row;
        };

        // 5. Modify createDexBoostTokenRow function - add Dex Paid tag
        const originalCreateDexBoostTokenRow = createDexBoostTokenRow;
        createDexBoostTokenRow = function(token) {
            const row = originalCreateDexBoostTokenRow(token);
            
            // Add the Dex Paid tag next to social links if applicable
            if (isDexPaid(token.token_address)) {
                const socialDiv = row.querySelector('.token-social');
                if (socialDiv) {
                    const dexPaidTag = document.createElement('span');
                    dexPaidTag.className = 'dex-paid-tag';
                    dexPaidTag.textContent = 'DEX PAID';
                    socialDiv.appendChild(dexPaidTag);
                }
            }
            
            return row;
        };

        // 6. Modify createThresholdTokenRow function - add Dex Paid tag
        const originalCreateThresholdTokenRow = createThresholdTokenRow;
        createThresholdTokenRow = function(token, tokenAddress, thresholdInfo) {
            const row = originalCreateThresholdTokenRow(token, tokenAddress, thresholdInfo);
            
            // Add the Dex Paid tag next to social links if applicable
            // Use thresholdInfo directly since we already have it
            if (thresholdInfo && thresholdInfo.dex_paid === true) {
                const socialDiv = row.querySelector('.token-social');
                if (socialDiv) {
                    const dexPaidTag = document.createElement('span');
                    dexPaidTag.className = 'dex-paid-tag';
                    dexPaidTag.textContent = 'DEX PAID';
                    socialDiv.appendChild(dexPaidTag);
                }
            }
            
            return row;
        };

        
        // Add this function to handle the history filter dropdown
        function initHistoryFilterDropdown() {
            const filterButton = document.getElementById('historyFilterButton');
            const filterDropdown = document.getElementById('historyFilterDropdown');
            const filterArrow = filterButton.querySelector('.filter-dropdown-arrow');
            
            // Toggle dropdown when filter button is clicked
            filterButton.addEventListener('click', function(e) {
                e.stopPropagation();
                filterDropdown.classList.toggle('show');
                filterArrow.classList.toggle('open');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!filterButton.contains(e.target) && !filterDropdown.contains(e.target)) {
                    filterDropdown.classList.remove('show');
                    filterArrow.classList.remove('open');
                }
            });

            // Prevent dropdown from closing when clicking inside it
            filterDropdown.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
        
        // 1. Add a new global variable to track the Dex Paid filter state
        let historyShowDexPaidOnly = false;

        // 2. Add the new checkbox element to the history filter dropdown
        function addDexPaidFilter() {
            // Get the dropdown container
            const dropdownContent = document.getElementById('historyFilterDropdown');
            
            if (!dropdownContent) {
                console.error('History filter dropdown not found');
                return;
            }
            
            // Create a new filter control div
            const filterControl = document.createElement('div');
            filterControl.className = 'filter-control';

            // Create a filter control for Late Bloomers
            const lateBloomersControl = document.createElement('div');
            lateBloomersControl.className = 'filter-control';

            // Create the checkbox input
            const lateBloomersCheckbox = document.createElement('input');
            lateBloomersCheckbox.type = 'checkbox';
            lateBloomersCheckbox.id = 'historyShowLateBloomerOnly';
            lateBloomersCheckbox.name = 'historyShowLateBloomerOnly';

            // Create the label
            const lateBloomersLabel = document.createElement('label');
            lateBloomersLabel.htmlFor = 'historyShowLateBloomerOnly';
            lateBloomersLabel.textContent = 'Late Bloomers';

            // Assemble the filter control
            lateBloomersControl.appendChild(lateBloomersCheckbox);
            lateBloomersControl.appendChild(lateBloomersLabel);

            // Create a filter control for Old Creations
            const oldCreationsControl = document.createElement('div');
            oldCreationsControl.className = 'filter-control';

            // Create the checkbox input
            const oldCreationsCheckbox = document.createElement('input');
            oldCreationsCheckbox.type = 'checkbox';
            oldCreationsCheckbox.id = 'historyShowOldCreationOnly';
            oldCreationsCheckbox.name = 'historyShowOldCreationOnly';

            // Create the label
            const oldCreationsLabel = document.createElement('label');
            oldCreationsLabel.htmlFor = 'historyShowOldCreationOnly';
            oldCreationsLabel.textContent = 'Old Creations';

            // Assemble the filter control
            oldCreationsControl.appendChild(oldCreationsCheckbox);
            oldCreationsControl.appendChild(oldCreationsLabel);

            // Add to the dropdown
            dropdownContent.appendChild(lateBloomersControl);
            dropdownContent.appendChild(oldCreationsControl);

            // Add event listeners
            lateBloomersCheckbox.addEventListener('change', function(event) {
                historyShowLateBloomerOnly = event.target.checked;
                renderHistoryTokensList(currentHistoryData);
                updateFilterButtonState();
            });

            oldCreationsCheckbox.addEventListener('change', function(event) {
                historyShowOldCreationOnly = event.target.checked;
                renderHistoryTokensList(currentHistoryData);
                updateFilterButtonState();
            });
            
            // Create the checkbox input
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = 'historyShowDexPaidOnly';
            checkbox.name = 'historyShowDexPaidOnly';
            
            // Create the label
            const label = document.createElement('label');
            label.htmlFor = 'historyShowDexPaidOnly';
            label.textContent = 'DEX Paid';
            
            // Assemble the filter control
            filterControl.appendChild(checkbox);
            filterControl.appendChild(label);
            
            // Add to the dropdown
            dropdownContent.appendChild(filterControl);
            
            // Add event listener
            checkbox.addEventListener('change', function(event) {
                historyShowDexPaidOnly = event.target.checked;
                renderHistoryTokensList(currentHistoryData);
            });
            
            console.log('Added DEX Paid filter to history widget');
        }

        // 3. Modify the applyHistoryFilters function to include the new filter
        function modifyApplyHistoryFilters() {
            // Store the original function
            const originalApplyHistoryFilters = applyHistoryFilters;
            
            // Override with new version that includes DEX Paid filtering
            applyHistoryFilters = function(data) {
                // Call the original function first to apply existing filters
                let filteredData = originalApplyHistoryFilters(data);
                
                // Apply DEX Paid filter if enabled
                if (historyShowDexPaidOnly) {
                    filteredData = filteredData.filter(token => isDexPaid(token.token_address));
                }
                
                return filteredData;
            };
            
            console.log('Modified applyHistoryFilters to include DEX Paid filtering');
        }

        // 4. Function to apply all changes
        function applyDexPaidFilterChanges() {
            // Add the new filter element
            addDexPaidFilter();
            
            // Modify the filter function
            modifyApplyHistoryFilters();
            
            // Re-render the history list to apply the filter
            if (currentHistoryData && currentHistoryData.length > 0) {
                renderHistoryTokensList(currentHistoryData);
            }
            
            console.log('DEX Paid filter implementation complete');
        }


        // If the document is already loaded, apply the changes immediately
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(applyDexPaidFilterChanges, 500);
        }

        // 1. Add global variable to track search term
        let historySearchTerm = '';

        // 2. Create function to add the search bar
        function addHistorySearchBar() {
            // Find the widget header (that contains the title)
            const widgetHeader = document.querySelector('#history-widget .widget-header');
            
            if (!widgetHeader) {
                console.error('History widget header not found');
                return;
            }
            
            // Create search bar container
            const searchBarContainer = document.createElement('div');
            searchBarContainer.className = 'history-search-container';
            searchBarContainer.style.display = 'flex';
            searchBarContainer.style.alignItems = 'center';
            searchBarContainer.style.width = '100%';
            searchBarContainer.style.marginTop = '5px';
            
            // Create search input
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'historySearchInput';
            searchInput.placeholder = 'Search tokens...';
            searchInput.style.padding = '4px 8px';
            searchInput.style.borderRadius = '4px';
            searchInput.style.border = '1px solid var(--border-color)';
            searchInput.style.backgroundColor = 'var(--widget-bg)';
            searchInput.style.color = 'var(--text-color)';
            searchInput.style.width = '200px';
            
            // Create clear button
            const clearButton = document.createElement('button');
            clearButton.textContent = '×';
            clearButton.style.marginLeft = '5px';
            clearButton.style.padding = '2px 6px';
            clearButton.style.borderRadius = '50%';
            clearButton.style.border = 'none';
            clearButton.style.backgroundColor = 'var(--border-color)';
            clearButton.style.color = 'var(--text-color)';
            clearButton.style.fontWeight = 'bold';
            clearButton.style.cursor = 'pointer';
            clearButton.style.display = 'none'; // Initially hidden
            
            // Add elements to container
            searchBarContainer.appendChild(searchInput);
            searchBarContainer.appendChild(clearButton);
            
            // Add to widget header - we'll let the key function position it
            widgetHeader.appendChild(searchBarContainer);
            
            // Add event listeners
            searchInput.addEventListener('input', function() {
                // Show/hide clear button based on input content
                clearButton.style.display = this.value ? 'block' : 'none';
                
                // Apply search filter and update the display
                applyHistorySearch(this.value);
            });
            
            clearButton.addEventListener('click', function() {
                // Clear the input
                searchInput.value = '';
                this.style.display = 'none';
                
                // Reset the search filter and update display
                applyHistorySearch('');
            });
            
            console.log('Added search bar to History widget');
        }

        // 3. Create function to apply search filtering
        function applyHistorySearch(searchTerm) {
            // Update the global variable
            historySearchTerm = searchTerm.trim().toLowerCase();
            
            // Re-render history tokens list with the current search term applied
            renderHistoryTokensList(currentHistoryData);
        }

        // 4. Enhance the applyHistoryFilters function to include search
        function enhanceApplyHistoryFiltersWithSearch() {
            // Store the original function
            const originalApplyHistoryFilters = applyHistoryFilters;
            
            // Override with new version that includes search functionality
            applyHistoryFilters = function(data) {
                // Call the original function first to apply existing filters
                let filteredData = originalApplyHistoryFilters(data);
                
                // Apply search filter if there's a search term
                if (historySearchTerm) {
                    filteredData = filteredData.filter(token => {
                        // Check token address
                        if (token.token_address && token.token_address.toLowerCase().includes(historySearchTerm)) {
                            return true;
                        }
                        
                        // Check token name
                        if (token.name && token.name.toLowerCase().includes(historySearchTerm)) {
                            return true;
                        }
                        
                        // Check token symbol
                        if (token.symbol && token.symbol.toLowerCase().includes(historySearchTerm)) {
                            return true;
                        }
                        
                        // None of the fields matched
                        return false;
                    });
                }
                
                return filteredData;
            };
            
            console.log('Enhanced applyHistoryFilters with search functionality');
        }

        // 5. Add CSS for the search bar
        function addSearchBarStyles() {
            const styleElement = document.createElement('style');
            styleElement.textContent = `
                .history-search-container {
                    display: flex;
                    align-items: center;
                    margin-left: auto;
                    margin-right: 10px;
                }
                
                #historySearchInput {
                    padding: 4px 8px;
                    border-radius: 4px;
                    border: 1px solid var(--border-color);
                    background-color: var(--widget-bg);
                    color: var(--text-color);
                    width: 150px;
                    transition: width 0.3s ease;
                }
                
                #historySearchInput:focus {
                    width: 180px;
                    outline: none;
                    border-color: var(--badge-bg);
                }
                
                #historySearchInput::placeholder {
                    color: var(--subtext-color);
                    opacity: 0.7;
                }
            `;
            document.head.appendChild(styleElement);
        }

        // 6. Apply all search bar changes
        function applyHistorySearchBarChanges() {
            // Add the search bar CSS
            addSearchBarStyles();
            
            // Add the search bar UI
            addHistorySearchBar();
            
            // Enhance the filter function with search capability
            enhanceApplyHistoryFiltersWithSearch();
            
            // Re-render the history list to apply initial state
            if (currentHistoryData && currentHistoryData.length > 0) {
                renderHistoryTokensList(currentHistoryData);
            }
            
            console.log('History search bar implementation complete');
        }

        // If the document is already loaded, apply the changes immediately
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(applyHistorySearchBarChanges, 1600);
        }

// 1. Add new global variables to track market cap and token age range filter values
let historyMinMarketCap = null;  // null means no minimum
let historyMaxMarketCap = null;  // null means no maximum
let historyMinTokenAge = null;   // null means no minimum (in minutes)
let historyMaxTokenAge = null;   // null means no maximum (in minutes)
let historyMinFarmPercentage = null;  // null means no minimum
let historyMaxFarmPercentage = null;  // null means no maximum

// New global variables for additional filters
let historyMinSusPercentage = null;   // null means no minimum
let historyMaxSusPercentage = null;   // null means no maximum
let historyMinDevPercentage = null;   // null means no minimum
let historyMaxDevPercentage = null;   // null means no maximum
let historyMinInsiderPercentage = null;   // null means no minimum
let historyMaxInsiderPercentage = null;   // null means no maximum

// Function to enhance the Market Cap Range Filter with additional metric filters
function enhanceMarketCapRangeFilter() {
    // Get the existing range container
    const rangeContainer = document.querySelector('.market-cap-range-container');
    
    if (!rangeContainer) {
        console.error('Range container not found');
        return;
    }
    
    // Get the button container (Apply and Clear buttons)
    const buttonContainer = rangeContainer.querySelector('div:last-child');
    
    // --- SUS% Range ---
    // Create a container for SUS% inputs
    const susPercentRowContainer = document.createElement('div');
    susPercentRowContainer.style.display = 'flex';
    susPercentRowContainer.style.alignItems = 'center';
    susPercentRowContainer.style.gap = '5px';
    susPercentRowContainer.style.marginBottom = '10px';
    
    // Create the SUS% label
    const susPercentLabel = document.createElement('label');
    susPercentLabel.textContent = 'SUS%:';
    susPercentLabel.style.whiteSpace = 'nowrap';
    
    // Create min SUS% input
    const minSusPercentInput = document.createElement('input');
    minSusPercentInput.type = 'number';
    minSusPercentInput.id = 'historyMinSusPercent';
    minSusPercentInput.name = 'historyMinSusPercent';
    minSusPercentInput.placeholder = 'Min %';
    minSusPercentInput.style.width = '70px';
    minSusPercentInput.style.padding = '4px';
    minSusPercentInput.style.borderRadius = '4px';
    minSusPercentInput.style.border = '1px solid var(--border-color)';
    minSusPercentInput.style.backgroundColor = 'var(--widget-bg)';
    minSusPercentInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toSusPercentText = document.createElement('span');
    toSusPercentText.textContent = 'to';
    toSusPercentText.style.margin = '0 5px';
    
    // Create max SUS% input
    const maxSusPercentInput = document.createElement('input');
    maxSusPercentInput.type = 'number';
    maxSusPercentInput.id = 'historyMaxSusPercent';
    maxSusPercentInput.name = 'historyMaxSusPercent';
    maxSusPercentInput.placeholder = 'Max %';
    maxSusPercentInput.style.width = '70px';
    maxSusPercentInput.style.padding = '4px';
    maxSusPercentInput.style.borderRadius = '4px';
    maxSusPercentInput.style.border = '1px solid var(--border-color)';
    maxSusPercentInput.style.backgroundColor = 'var(--widget-bg)';
    maxSusPercentInput.style.color = 'var(--text-color)';
    
    // Add elements to SUS% row
    susPercentRowContainer.appendChild(susPercentLabel);
    susPercentRowContainer.appendChild(minSusPercentInput);
    susPercentRowContainer.appendChild(toSusPercentText);
    susPercentRowContainer.appendChild(maxSusPercentInput);
    
    // --- DEV% Range ---
    // Create a container for DEV% inputs
    const devPercentRowContainer = document.createElement('div');
    devPercentRowContainer.style.display = 'flex';
    devPercentRowContainer.style.alignItems = 'center';
    devPercentRowContainer.style.gap = '5px';
    devPercentRowContainer.style.marginBottom = '10px';
    
    // Create the DEV% label
    const devPercentLabel = document.createElement('label');
    devPercentLabel.textContent = 'DEV%:';
    devPercentLabel.style.whiteSpace = 'nowrap';
    
    // Create min DEV% input
    const minDevPercentInput = document.createElement('input');
    minDevPercentInput.type = 'number';
    minDevPercentInput.id = 'historyMinDevPercent';
    minDevPercentInput.name = 'historyMinDevPercent';
    minDevPercentInput.placeholder = 'Min %';
    minDevPercentInput.style.width = '70px';
    minDevPercentInput.style.padding = '4px';
    minDevPercentInput.style.borderRadius = '4px';
    minDevPercentInput.style.border = '1px solid var(--border-color)';
    minDevPercentInput.style.backgroundColor = 'var(--widget-bg)';
    minDevPercentInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toDevPercentText = document.createElement('span');
    toDevPercentText.textContent = 'to';
    toDevPercentText.style.margin = '0 5px';
    
    // Create max DEV% input
    const maxDevPercentInput = document.createElement('input');
    maxDevPercentInput.type = 'number';
    maxDevPercentInput.id = 'historyMaxDevPercent';
    maxDevPercentInput.name = 'historyMaxDevPercent';
    maxDevPercentInput.placeholder = 'Max %';
    maxDevPercentInput.style.width = '70px';
    maxDevPercentInput.style.padding = '4px';
    maxDevPercentInput.style.borderRadius = '4px';
    maxDevPercentInput.style.border = '1px solid var(--border-color)';
    maxDevPercentInput.style.backgroundColor = 'var(--widget-bg)';
    maxDevPercentInput.style.color = 'var(--text-color)';
    
    // Add elements to DEV% row
    devPercentRowContainer.appendChild(devPercentLabel);
    devPercentRowContainer.appendChild(minDevPercentInput);
    devPercentRowContainer.appendChild(toDevPercentText);
    devPercentRowContainer.appendChild(maxDevPercentInput);
    
    // --- INSIDER% Range ---
    // Create a container for INSIDER% inputs
    const insiderPercentRowContainer = document.createElement('div');
    insiderPercentRowContainer.style.display = 'flex';
    insiderPercentRowContainer.style.alignItems = 'center';
    insiderPercentRowContainer.style.gap = '5px';
    insiderPercentRowContainer.style.marginBottom = '10px';
    
    // Create the INSIDER% label
    const insiderPercentLabel = document.createElement('label');
    insiderPercentLabel.textContent = 'INSIDER%:';
    insiderPercentLabel.style.whiteSpace = 'nowrap';
    
    // Create min INSIDER% input
    const minInsiderPercentInput = document.createElement('input');
    minInsiderPercentInput.type = 'number';
    minInsiderPercentInput.id = 'historyMinInsiderPercent';
    minInsiderPercentInput.name = 'historyMinInsiderPercent';
    minInsiderPercentInput.placeholder = 'Min %';
    minInsiderPercentInput.style.width = '70px';
    minInsiderPercentInput.style.padding = '4px';
    minInsiderPercentInput.style.borderRadius = '4px';
    minInsiderPercentInput.style.border = '1px solid var(--border-color)';
    minInsiderPercentInput.style.backgroundColor = 'var(--widget-bg)';
    minInsiderPercentInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toInsiderPercentText = document.createElement('span');
    toInsiderPercentText.textContent = 'to';
    toInsiderPercentText.style.margin = '0 5px';
    
    // Create max INSIDER% input
    const maxInsiderPercentInput = document.createElement('input');
    maxInsiderPercentInput.type = 'number';
    maxInsiderPercentInput.id = 'historyMaxInsiderPercent';
    maxInsiderPercentInput.name = 'historyMaxInsiderPercent';
    maxInsiderPercentInput.placeholder = 'Max %';
    maxInsiderPercentInput.style.width = '70px';
    maxInsiderPercentInput.style.padding = '4px';
    maxInsiderPercentInput.style.borderRadius = '4px';
    maxInsiderPercentInput.style.border = '1px solid var(--border-color)';
    maxInsiderPercentInput.style.backgroundColor = 'var(--widget-bg)';
    maxInsiderPercentInput.style.color = 'var(--text-color)';
    
    // Add elements to INSIDER% row
    insiderPercentRowContainer.appendChild(insiderPercentLabel);
    insiderPercentRowContainer.appendChild(minInsiderPercentInput);
    insiderPercentRowContainer.appendChild(toInsiderPercentText);
    insiderPercentRowContainer.appendChild(maxInsiderPercentInput);
    
    // Insert all the new rows before the button container
    rangeContainer.insertBefore(susPercentRowContainer, buttonContainer);
    rangeContainer.insertBefore(devPercentRowContainer, buttonContainer);
    rangeContainer.insertBefore(insiderPercentRowContainer, buttonContainer);
    
    // Get references to the Apply and Clear buttons
    const applyButton = document.getElementById('historyApplyRanges');
    const clearButton = document.getElementById('historyClearRanges');
    
    // Update the Apply button click handler
    if (applyButton) {
        // Store the original click handler
        const originalClickHandler = applyButton.onclick;
        
        // Set new click handler
        applyButton.onclick = function(event) {
            // Call original handler if it exists
            if (originalClickHandler) {
                originalClickHandler.call(this, event);
            }
            
            // Get our new filter values
            const minSusValue = minSusPercentInput.value.trim() === '' ? null : parseFloat(minSusPercentInput.value);
            const maxSusValue = maxSusPercentInput.value.trim() === '' ? null : parseFloat(maxSusPercentInput.value);
            
            const minDevValue = minDevPercentInput.value.trim() === '' ? null : parseFloat(minDevPercentInput.value);
            const maxDevValue = maxDevPercentInput.value.trim() === '' ? null : parseFloat(maxDevPercentInput.value);
            
            const minInsiderValue = minInsiderPercentInput.value.trim() === '' ? null : parseFloat(minInsiderPercentInput.value);
            const maxInsiderValue = maxInsiderPercentInput.value.trim() === '' ? null : parseFloat(maxInsiderPercentInput.value);
            
            // Set global variables
            historyMinSusPercentage = minSusValue;
            historyMaxSusPercentage = maxSusValue;
            historyMinDevPercentage = minDevValue;
            historyMaxDevPercentage = maxDevValue;
            historyMinInsiderPercentage = minInsiderValue;
            historyMaxInsiderPercentage = maxInsiderValue;
            
            // Re-render tokens list
            renderHistoryTokensList(currentHistoryData);
            
            // Update filter button visual indicator
            const filterButton = document.getElementById('historyFilterButton');
            if ((historyMinSusPercentage !== null || historyMaxSusPercentage !== null || 
                 historyMinDevPercentage !== null || historyMaxDevPercentage !== null ||
                 historyMinInsiderPercentage !== null || historyMaxInsiderPercentage !== null) && filterButton) {
                if (!filterButton.classList.contains('active-filter')) {
                    filterButton.classList.add('active-filter');
                    filterButton.style.backgroundColor = 'var(--boost-badge-bg)';
                }
            }
        };
    }
    
    // Update the Clear button click handler
    if (clearButton) {
        // Store the original click handler
        const originalClickHandler = clearButton.onclick;
        
        // Set new click handler
        clearButton.onclick = function(event) {
            // Call original handler if it exists
            if (originalClickHandler) {
                originalClickHandler.call(this, event);
            }
            
            // Clear our new input fields
            minSusPercentInput.value = '';
            maxSusPercentInput.value = '';
            minDevPercentInput.value = '';
            maxDevPercentInput.value = '';
            minInsiderPercentInput.value = '';
            maxInsiderPercentInput.value = '';
            
            // Reset global variables
            historyMinSusPercentage = null;
            historyMaxSusPercentage = null;
            historyMinDevPercentage = null;
            historyMaxDevPercentage = null;
            historyMinInsiderPercentage = null;
            historyMaxInsiderPercentage = null;
            
            // Re-render tokens list
            renderHistoryTokensList(currentHistoryData);
            
            // Update filter button visual indicator
            const filterButton = document.getElementById('historyFilterButton');
            
            // Check if ANY filter is active
            const isAnyFilterActive = 
                historyFilterSocialLinks || 
                historyExcludeFarmTokens || 
                historyShowDexPaidOnly ||
                historyMinMarketCap !== null ||
                historyMaxMarketCap !== null ||
                historyMinTokenAge !== null ||
                historyMaxTokenAge !== null ||
                historyMinFarmPercentage !== null ||
                historyMaxFarmPercentage !== null;
            
            if (!isAnyFilterActive && filterButton && filterButton.classList.contains('active-filter')) {
                filterButton.classList.remove('active-filter');
                filterButton.style.backgroundColor = '';
            }
        };
    }
    
    console.log('Added SUS%, DEV%, and INSIDER% range filters to history widget');
}

// 3. Modify the addMarketCapRangeFilter function to include the FARM% filter
function addMarketCapRangeFilter() {
    // Get the dropdown container
    const dropdownContent = document.getElementById('historyFilterDropdown');
    
    if (!dropdownContent) {
        console.error('History filter dropdown not found');
        return;
    }
    
    // Create container for all range filters
    const rangeContainer = document.createElement('div');
    rangeContainer.className = 'market-cap-range-container';
    rangeContainer.style.padding = '5px 16px';
    rangeContainer.style.display = 'flex';
    rangeContainer.style.flexDirection = 'column';
    rangeContainer.style.gap = '5px';
    
    // --- Market Cap Range ---
    // Create a container for market cap inputs
    const marketCapRowContainer = document.createElement('div');
    marketCapRowContainer.style.display = 'flex';
    marketCapRowContainer.style.alignItems = 'center';
    marketCapRowContainer.style.gap = '5px';
    marketCapRowContainer.style.marginBottom = '5px';
    
    // Create the Market Cap label
    const marketCapLabel = document.createElement('label');
    marketCapLabel.textContent = 'Market Cap:';
    marketCapLabel.style.whiteSpace = 'nowrap';
    
    // Create min market cap input
    const minMarketCapInput = document.createElement('input');
    minMarketCapInput.type = 'number';
    minMarketCapInput.id = 'historyMinMarketCap';
    minMarketCapInput.name = 'historyMinMarketCap';
    minMarketCapInput.placeholder = 'Min $';
    minMarketCapInput.style.width = '70px';
    minMarketCapInput.style.padding = '4px';
    minMarketCapInput.style.borderRadius = '4px';
    minMarketCapInput.style.border = '1px solid var(--border-color)';
    minMarketCapInput.style.backgroundColor = 'var(--widget-bg)';
    minMarketCapInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toMarketCapText = document.createElement('span');
    toMarketCapText.textContent = 'to';
    toMarketCapText.style.margin = '0 5px';
    
    // Create max market cap input
    const maxMarketCapInput = document.createElement('input');
    maxMarketCapInput.type = 'number';
    maxMarketCapInput.id = 'historyMaxMarketCap';
    maxMarketCapInput.name = 'historyMaxMarketCap';
    maxMarketCapInput.placeholder = 'Max $';
    maxMarketCapInput.style.width = '70px';
    maxMarketCapInput.style.padding = '4px';
    maxMarketCapInput.style.borderRadius = '4px';
    maxMarketCapInput.style.border = '1px solid var(--border-color)';
    maxMarketCapInput.style.backgroundColor = 'var(--widget-bg)';
    maxMarketCapInput.style.color = 'var(--text-color)';
    
    // Add elements to market cap row
    marketCapRowContainer.appendChild(marketCapLabel);
    marketCapRowContainer.appendChild(minMarketCapInput);
    marketCapRowContainer.appendChild(toMarketCapText);
    marketCapRowContainer.appendChild(maxMarketCapInput);
    
    // --- Token Age Range ---
    // Create a container for token age inputs
    const tokenAgeRowContainer = document.createElement('div');
    tokenAgeRowContainer.style.display = 'flex';
    tokenAgeRowContainer.style.alignItems = 'center';
    tokenAgeRowContainer.style.gap = '5px';
    tokenAgeRowContainer.style.marginBottom = '10px';
    
    // Create the Token Age label
    const tokenAgeLabel = document.createElement('label');
    tokenAgeLabel.textContent = 'Age (Mins):';
    tokenAgeLabel.style.whiteSpace = 'nowrap';
    
    // Create min token age input
    const minTokenAgeInput = document.createElement('input');
    minTokenAgeInput.type = 'number';
    minTokenAgeInput.id = 'historyMinTokenAge';
    minTokenAgeInput.name = 'historyMinTokenAge';
    minTokenAgeInput.placeholder = 'Min';
    minTokenAgeInput.style.width = '70px';
    minTokenAgeInput.style.padding = '4px';
    minTokenAgeInput.style.borderRadius = '4px';
    minTokenAgeInput.style.border = '1px solid var(--border-color)';
    minTokenAgeInput.style.backgroundColor = 'var(--widget-bg)';
    minTokenAgeInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toTokenAgeText = document.createElement('span');
    toTokenAgeText.textContent = 'to';
    toTokenAgeText.style.margin = '0 5px';
    
    // Create max token age input
    const maxTokenAgeInput = document.createElement('input');
    maxTokenAgeInput.type = 'number';
    maxTokenAgeInput.id = 'historyMaxTokenAge';
    maxTokenAgeInput.name = 'historyMaxTokenAge';
    maxTokenAgeInput.placeholder = 'Max';
    maxTokenAgeInput.style.width = '70px';
    maxTokenAgeInput.style.padding = '4px';
    maxTokenAgeInput.style.borderRadius = '4px';
    maxTokenAgeInput.style.border = '1px solid var(--border-color)';
    maxTokenAgeInput.style.backgroundColor = 'var(--widget-bg)';
    maxTokenAgeInput.style.color = 'var(--text-color)';
    
    // Add elements to token age row
    tokenAgeRowContainer.appendChild(tokenAgeLabel);
    tokenAgeRowContainer.appendChild(minTokenAgeInput);
    tokenAgeRowContainer.appendChild(toTokenAgeText);
    tokenAgeRowContainer.appendChild(maxTokenAgeInput);
    
    // Create button container
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.marginTop = '5px';
    
    // Create apply button
    const applyButton = document.createElement('button');
    applyButton.id = 'historyApplyRanges';
    applyButton.textContent = 'Apply Filters';
    applyButton.style.padding = '4px 10px';
    applyButton.style.borderRadius = '4px';
    applyButton.style.border = 'none';
    applyButton.style.backgroundColor = 'var(--badge-bg)';
    applyButton.style.color = 'var(--badge-color)';
    applyButton.style.cursor = 'pointer';
    applyButton.style.fontWeight = 'bold';
    
    // Create clear button
    const clearButton = document.createElement('button');
    clearButton.id = 'historyClearRanges';
    clearButton.textContent = 'Clear All';
    clearButton.style.marginLeft = '5px';
    clearButton.style.padding = '4px 10px';
    clearButton.style.borderRadius = '4px';
    clearButton.style.border = 'none';
    clearButton.style.backgroundColor = 'var(--copy-bg)';
    clearButton.style.color = 'var(--text-color)';
    clearButton.style.cursor = 'pointer';
    
    // Add buttons to container
    buttonContainer.appendChild(applyButton);
    buttonContainer.appendChild(clearButton);
    
    // --- FARM% Range ---
    // Create a container for FARM% inputs
    const farmPercentRowContainer = document.createElement('div');
    farmPercentRowContainer.style.display = 'flex';
    farmPercentRowContainer.style.alignItems = 'center';
    farmPercentRowContainer.style.gap = '5px';
    farmPercentRowContainer.style.marginBottom = '10px';
    
    // Create the FARM% label
    const farmPercentLabel = document.createElement('label');
    farmPercentLabel.textContent = 'FARM%:';
    farmPercentLabel.style.whiteSpace = 'nowrap';
    
    // Create min FARM% input
    const minFarmPercentInput = document.createElement('input');
    minFarmPercentInput.type = 'number';
    minFarmPercentInput.id = 'historyMinFarmPercent';
    minFarmPercentInput.name = 'historyMinFarmPercent';
    minFarmPercentInput.placeholder = 'Min %';
    minFarmPercentInput.style.width = '70px';
    minFarmPercentInput.style.padding = '4px';
    minFarmPercentInput.style.borderRadius = '4px';
    minFarmPercentInput.style.border = '1px solid var(--border-color)';
    minFarmPercentInput.style.backgroundColor = 'var(--widget-bg)';
    minFarmPercentInput.style.color = 'var(--text-color)';
    
    // Create "to" text element
    const toFarmPercentText = document.createElement('span');
    toFarmPercentText.textContent = 'to';
    toFarmPercentText.style.margin = '0 5px';
    
    // Create max FARM% input
    const maxFarmPercentInput = document.createElement('input');
    maxFarmPercentInput.type = 'number';
    maxFarmPercentInput.id = 'historyMaxFarmPercent';
    maxFarmPercentInput.name = 'historyMaxFarmPercent';
    maxFarmPercentInput.placeholder = 'Max %';
    maxFarmPercentInput.style.width = '70px';
    maxFarmPercentInput.style.padding = '4px';
    maxFarmPercentInput.style.borderRadius = '4px';
    maxFarmPercentInput.style.border = '1px solid var(--border-color)';
    maxFarmPercentInput.style.backgroundColor = 'var(--widget-bg)';
    maxFarmPercentInput.style.color = 'var(--text-color)';
    
    // Add elements to FARM% row
    farmPercentRowContainer.appendChild(farmPercentLabel);
    farmPercentRowContainer.appendChild(minFarmPercentInput);
    farmPercentRowContainer.appendChild(toFarmPercentText);
    farmPercentRowContainer.appendChild(maxFarmPercentInput);
    
    // Add all rows and buttons to the range container
    rangeContainer.appendChild(marketCapRowContainer);
    rangeContainer.appendChild(tokenAgeRowContainer);
    rangeContainer.appendChild(farmPercentRowContainer);
    rangeContainer.appendChild(buttonContainer);
    
    // Add to the dropdown
    dropdownContent.appendChild(rangeContainer);
    
    // Style placeholder text to appear grayed out
    const placeholderStyle = document.createElement('style');
    placeholderStyle.textContent = `
        #historyMinMarketCap::placeholder, 
        #historyMaxMarketCap::placeholder,
        #historyMinTokenAge::placeholder, 
        #historyMaxTokenAge::placeholder {
            color: var(--subtext-color);
            opacity: 0.7;
        }
    `;
    document.head.appendChild(placeholderStyle);
    
    // Add event listeners
    applyButton.addEventListener('click', function() {
        // Get market cap values
        const minMarketCapValue = minMarketCapInput.value.trim() === '' ? null : parseFloat(minMarketCapInput.value);
        const maxMarketCapValue = maxMarketCapInput.value.trim() === '' ? null : parseFloat(maxMarketCapInput.value);
        
        // Get token age values
        const minTokenAgeValue = minTokenAgeInput.value.trim() === '' ? null : parseFloat(minTokenAgeInput.value);
        const maxTokenAgeValue = maxTokenAgeInput.value.trim() === '' ? null : parseFloat(maxTokenAgeInput.value);
        
        // Get FARM% values
        const minFarmPercentValue = minFarmPercentInput.value.trim() === '' ? null : parseFloat(minFarmPercentInput.value);
        const maxFarmPercentValue = maxFarmPercentInput.value.trim() === '' ? null : parseFloat(maxFarmPercentInput.value);
        
        // Set global variables
        historyMinMarketCap = minMarketCapValue;
        historyMaxMarketCap = maxMarketCapValue;
        historyMinTokenAge = minTokenAgeValue;
        historyMaxTokenAge = maxTokenAgeValue;
        historyMinFarmPercentage = minFarmPercentValue;
        historyMaxFarmPercentage = maxFarmPercentValue;
        
        // Re-render tokens list
        renderHistoryTokensList(currentHistoryData);
        
        // Add visual indicator on the filter button if any range is active
        const filterButton = document.getElementById('historyFilterButton');
        if ((historyMinMarketCap !== null || historyMaxMarketCap !== null || 
             historyMinTokenAge !== null || historyMaxTokenAge !== null ||
             historyMinFarmPercentage !== null || historyMaxFarmPercentage !== null) && filterButton) {
            if (!filterButton.classList.contains('active-filter')) {
                filterButton.classList.add('active-filter');
                filterButton.style.backgroundColor = 'var(--boost-badge-bg)';
            }
        }
    });
    
    clearButton.addEventListener('click', function() {
        // Clear all input values
        minMarketCapInput.value = '';
        maxMarketCapInput.value = '';
        minTokenAgeInput.value = '';
        maxTokenAgeInput.value = '';
        minFarmPercentInput.value = '';
        maxFarmPercentInput.value = '';
        
        // Reset global variables
        historyMinMarketCap = null;
        historyMaxMarketCap = null;
        historyMinTokenAge = null;
        historyMaxTokenAge = null;
        historyMinFarmPercentage = null;
        historyMaxFarmPercentage = null;
        
        // Re-render tokens list
        renderHistoryTokensList(currentHistoryData);
        
        // Remove visual indicator on the filter button if no other filters are active
        const filterButton = document.getElementById('historyFilterButton');
        if (filterButton && 
            filterButton.classList.contains('active-filter') && 
            !historyFilterSocialLinks && 
            !historyExcludeFarmTokens && 
            !historyShowDexPaidOnly) {
            filterButton.classList.remove('active-filter');
            filterButton.style.backgroundColor = '';
        }
    });
    
    console.log('Added market cap and token age range filters to history widget');
}



// Function to add source filters to the top of the dropdown menu
// Function to add source filters to the top of the dropdown menu
function addSourceFilters() {
    // Get the dropdown container
    const dropdownContent = document.getElementById('historyFilterDropdown');
    
    if (!dropdownContent) {
        console.error('History filter dropdown not found');
        return;
    }
    
    // First, remove any existing source filter elements to avoid duplicates
    const existingHeader = dropdownContent.querySelector('.filter-section-header');
    if (existingHeader) {
        existingHeader.parentNode.removeChild(existingHeader);
    }
    
    // Remove existing source checkboxes if they exist
    const existingPumpFunControl = dropdownContent.querySelector('[for="historyShowPumpFunOnly"]');
    if (existingPumpFunControl) {
        const controlDiv = existingPumpFunControl.parentNode;
        if (controlDiv) controlDiv.parentNode.removeChild(controlDiv);
    }
    
    const existingRaydiumControl = dropdownContent.querySelector('[for="historyShowRaydiumOnly"]');
    if (existingRaydiumControl) {
        const controlDiv = existingRaydiumControl.parentNode;
        if (controlDiv) controlDiv.parentNode.removeChild(controlDiv);
    }
    
    const existingMeteoraControl = dropdownContent.querySelector('[for="historyShowMeteoraOnly"]');
    if (existingMeteoraControl) {
        const controlDiv = existingMeteoraControl.parentNode;
        if (controlDiv) controlDiv.parentNode.removeChild(controlDiv);
    }
    
    // Remove existing toggle all button
    const existingToggleButton = dropdownContent.querySelector('.toggle-all-button');
    if (existingToggleButton) {
        const buttonContainer = existingToggleButton.parentNode;
        if (buttonContainer) buttonContainer.parentNode.removeChild(buttonContainer);
    }
    
    // Get the first child of the dropdown (to insert before it)
    const firstChild = dropdownContent.firstChild;
    
    // Create a section header for source filters
    const sourceFilterHeader = document.createElement('div');
    sourceFilterHeader.className = 'filter-section-header';
    sourceFilterHeader.textContent = 'Token Source';
    sourceFilterHeader.style.fontWeight = 'bold';
    sourceFilterHeader.style.marginTop = '5px';
    sourceFilterHeader.style.marginBottom = '5px';
    sourceFilterHeader.style.padding = '0 16px';
    sourceFilterHeader.style.color = 'var(--header-color)';
    
    // Create a filter control for PumpFun tokens
    const pumpFunControl = document.createElement('div');
    pumpFunControl.className = 'filter-control';
    
    // Create the checkbox for PumpFun
    const pumpFunCheckbox = document.createElement('input');
    pumpFunCheckbox.type = 'checkbox';
    pumpFunCheckbox.id = 'historyShowPumpFunOnly';
    pumpFunCheckbox.name = 'historyShowPumpFunOnly';
    pumpFunCheckbox.checked = historyShowPumpFunOnly; // Set initial state
    
    // Create the label for PumpFun
    const pumpFunLabel = document.createElement('label');
    pumpFunLabel.htmlFor = 'historyShowPumpFunOnly';
    pumpFunLabel.textContent = 'PumpFun Tokens';
    
    // Assemble the PumpFun control
    pumpFunControl.appendChild(pumpFunCheckbox);
    pumpFunControl.appendChild(pumpFunLabel);
    
    // Create a filter control for Raydium tokens
    const raydiumControl = document.createElement('div');
    raydiumControl.className = 'filter-control';
    
    // Create the checkbox for Raydium
    const raydiumCheckbox = document.createElement('input');
    raydiumCheckbox.type = 'checkbox';
    raydiumCheckbox.id = 'historyShowRaydiumOnly';
    raydiumCheckbox.name = 'historyShowRaydiumOnly';
    raydiumCheckbox.checked = historyShowRaydiumOnly; // Set initial state
    
    // Create the label for Raydium
    const raydiumLabel = document.createElement('label');
    raydiumLabel.htmlFor = 'historyShowRaydiumOnly';
    raydiumLabel.textContent = 'Raydium Launchpad Tokens';
    
    // Assemble the Raydium control
    raydiumControl.appendChild(raydiumCheckbox);
    raydiumControl.appendChild(raydiumLabel);
    
    // Create a filter control for Meteora tokens
    const meteoraControl = document.createElement('div');
    meteoraControl.className = 'filter-control';

    // Create the checkbox for Meteora
    const meteoraCheckbox = document.createElement('input');
    meteoraCheckbox.type = 'checkbox';
    meteoraCheckbox.id = 'historyShowMeteoraOnly';
    meteoraCheckbox.name = 'historyShowMeteoraOnly';
    meteoraCheckbox.checked = historyShowMeteoraOnly; // Set initial state

    // Create the label for Meteora
    const meteoraLabel = document.createElement('label');
    meteoraLabel.htmlFor = 'historyShowMeteoraOnly';
    meteoraLabel.textContent = 'Meteora Launchpad Tokens';

    // Assemble the Meteora control
    meteoraControl.appendChild(meteoraCheckbox);
    meteoraControl.appendChild(meteoraLabel);
    
    // Create toggle all button container
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'center';
    buttonContainer.style.padding = '5px 16px';
    
    const toggleButton = document.createElement('button');
    toggleButton.textContent = 'Toggle All Sources';
    toggleButton.className = 'toggle-all-button';
    toggleButton.style.padding = '4px 10px';
    toggleButton.style.backgroundColor = 'var(--badge-bg)';
    toggleButton.style.color = 'var(--badge-color)';
    toggleButton.style.border = 'none';
    toggleButton.style.borderRadius = '4px';
    toggleButton.style.cursor = 'pointer';
    toggleButton.style.fontWeight = 'bold';
    
    // Make toggle button control all three sources
    toggleButton.addEventListener('click', function() {
        // Check if all are currently selected
        const allSelected = historyShowPumpFunOnly && historyShowRaydiumOnly && historyShowMeteoraOnly;
        
        // Toggle to opposite state (all on or all off)
        historyShowPumpFunOnly = !allSelected;
        historyShowRaydiumOnly = !allSelected;
        historyShowMeteoraOnly = !allSelected;
        
        // Update checkboxes
        pumpFunCheckbox.checked = !allSelected;
        raydiumCheckbox.checked = !allSelected;
        meteoraCheckbox.checked = !allSelected;
        
        // Re-render the token list
        renderHistoryTokensList(currentHistoryData);
        updateFilterButtonState();
    });
    
    buttonContainer.appendChild(toggleButton);
    
    // Create a separator for after the source filters
    const separator = document.createElement('hr');
    separator.style.margin = '10px 16px';
    separator.style.border = 'none';
    separator.style.borderTop = '1px solid var(--border-color)';
    
    // Insert elements at the beginning of the dropdown
    if (firstChild) {
        dropdownContent.insertBefore(separator, firstChild);
        dropdownContent.insertBefore(buttonContainer, separator);
        dropdownContent.insertBefore(meteoraControl, buttonContainer);
        dropdownContent.insertBefore(raydiumControl, meteoraControl);
        dropdownContent.insertBefore(pumpFunControl, raydiumControl);
        dropdownContent.insertBefore(sourceFilterHeader, pumpFunControl);
    } else {
        // If dropdown is empty, just append elements
        dropdownContent.appendChild(sourceFilterHeader);
        dropdownContent.appendChild(pumpFunControl);
        dropdownContent.appendChild(raydiumControl);
        dropdownContent.appendChild(meteoraControl);
        dropdownContent.appendChild(buttonContainer);
        dropdownContent.appendChild(separator);
    }
    
    // Add event listeners
    pumpFunCheckbox.addEventListener('change', function(event) {
        historyShowPumpFunOnly = event.target.checked;
        
        // If all are deselected, enable all (prevent no selection state)
        if (!historyShowPumpFunOnly && !historyShowRaydiumOnly && !historyShowMeteoraOnly) {
            historyShowPumpFunOnly = true;
            historyShowRaydiumOnly = true;
            historyShowMeteoraOnly = true;
            pumpFunCheckbox.checked = true;
            raydiumCheckbox.checked = true;
            meteoraCheckbox.checked = true;
        }
        
        renderHistoryTokensList(currentHistoryData);
        updateFilterButtonState();
    });
    
    raydiumCheckbox.addEventListener('change', function(event) {
        historyShowRaydiumOnly = event.target.checked;
        
        // If all are deselected, enable all (prevent no selection state)
        if (!historyShowPumpFunOnly && !historyShowRaydiumOnly && !historyShowMeteoraOnly) {
            historyShowPumpFunOnly = true;
            historyShowRaydiumOnly = true;
            historyShowMeteoraOnly = true;
            pumpFunCheckbox.checked = true;
            raydiumCheckbox.checked = true;
            meteoraCheckbox.checked = true;
        }
        
        renderHistoryTokensList(currentHistoryData);
        updateFilterButtonState();
    });
    
    meteoraCheckbox.addEventListener('change', function(event) {
        historyShowMeteoraOnly = event.target.checked;
        
        // If all are deselected, enable all (prevent no selection state)
        if (!historyShowPumpFunOnly && !historyShowRaydiumOnly && !historyShowMeteoraOnly) {
            historyShowPumpFunOnly = true;
            historyShowRaydiumOnly = true;
            historyShowMeteoraOnly = true;
            pumpFunCheckbox.checked = true;
            raydiumCheckbox.checked = true;
            meteoraCheckbox.checked = true;
        }
        
        renderHistoryTokensList(currentHistoryData);
        updateFilterButtonState();
    });
    
    console.log('Added source filters to the top of history widget dropdown');
    
    // Also update or disable any separate addToggleAllSourcesButton function
    // that might be adding a duplicate button
    if (typeof window.addToggleAllSourcesButton === 'function') {
        // Override the original function to do nothing
        window.addToggleAllSourcesButton = function() {
            console.log('Original addToggleAllSourcesButton function disabled');
        };
    }
}

// Function to add classification filters to the dropdown menu
function addClassificationFilters() {
    // Get the dropdown container
    const dropdownContent = document.getElementById('historyFilterDropdown');
    
    if (!dropdownContent) {
        console.error('History filter dropdown not found');
        return;
    }
    
    // Create a separator for the classification filters
    const separator = document.createElement('hr');
    separator.style.margin = '10px 16px';
    separator.style.border = 'none';
    separator.style.borderTop = '1px solid var(--border-color)';
    
    // Create a section header for classification filters
    const classificationFilterHeader = document.createElement('div');
    classificationFilterHeader.className = 'filter-section-header';
    classificationFilterHeader.textContent = 'Token Classifications';
    classificationFilterHeader.style.fontWeight = 'bold';
    classificationFilterHeader.style.marginTop = '10px';
    classificationFilterHeader.style.marginBottom = '5px';
    classificationFilterHeader.style.padding = '0 16px';
    classificationFilterHeader.style.color = 'var(--header-color)';
    
    // Define classification options
    const classificationOptions = [
        { key: 'memecoin', label: 'Memecoin', variable: 'historyShowMemecoin' },
        { key: 'utility', label: 'Utility', variable: 'historyShowUtility' },
        { key: 'ai_token', label: 'AI Token', variable: 'historyShowAiToken' },
        { key: 'tweet_coin', label: 'Tweet Coin', variable: 'historyShowTweetCoin' },
        { key: 'current_event', label: 'Current Event', variable: 'historyShowCurrentEvent' },
        { key: 'racist', label: 'Racist', variable: 'historyShowRacist' },
        { key: 'offensive', label: 'Offensive', variable: 'historyShowOffensive' },
        { key: 'animals', label: 'Animals', variable: 'historyShowAnimals' },
        { key: 'political', label: 'Political', variable: 'historyShowPolitical' }
    ];
    
    // Add separator and header
    dropdownContent.appendChild(separator);
    dropdownContent.appendChild(classificationFilterHeader);
    
    // Create filter controls for each classification
    classificationOptions.forEach(option => {
        const filterControl = document.createElement('div');
        filterControl.className = 'filter-control';
        
        // Create the checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `historyShow${option.key.charAt(0).toUpperCase() + option.key.slice(1).replace('_', '')}`;
        checkbox.name = checkbox.id;
        checkbox.checked = true; // All checked by default
        
        // Create the label
        const label = document.createElement('label');
        label.htmlFor = checkbox.id;
        label.textContent = option.label;
        
        // Assemble the filter control
        filterControl.appendChild(checkbox);
        filterControl.appendChild(label);
        
        // Add to the dropdown
        dropdownContent.appendChild(filterControl);
        
        // Add event listener
        checkbox.addEventListener('change', function(event) {
            // Update the corresponding global variable
            switch(option.key) {
                case 'memecoin':
                    historyShowMemecoin = event.target.checked;
                    break;
                case 'utility':
                    historyShowUtility = event.target.checked;
                    break;
                case 'ai_token':
                    historyShowAiToken = event.target.checked;
                    break;
                case 'tweet_coin':
                    historyShowTweetCoin = event.target.checked;
                    break;
                case 'current_event':
                    historyShowCurrentEvent = event.target.checked;
                    break;
                case 'racist':
                    historyShowRacist = event.target.checked;
                    break;
                case 'offensive':
                    historyShowOffensive = event.target.checked;
                    break;
                case 'animals':
                    historyShowAnimals = event.target.checked;
                    break;
                case 'political':
                    historyShowPolitical = event.target.checked;
                    break;
            }
            
            // Re-render the history tokens list
            renderHistoryTokensList(currentHistoryData);
            updateFilterButtonState();
        });
    });
    
    console.log('Added classification filters to history widget dropdown');
}

// Helper function to update filter button appearance
function updateFilterButtonState() {
    const filterButton = document.getElementById('historyFilterButton');
    if (!filterButton) return;
    
    const isAnyFilterActive = 
        historyFilterSocialLinks || 
        historyExcludeFarmTokens || 
        historyShowDexPaidOnly ||
        historyMinMarketCap !== null ||
        historyMaxMarketCap !== null ||
        historyMinTokenAge !== null ||
        historyMaxTokenAge !== null ||
        historyMinFarmPercentage !== null ||
        historyMaxFarmPercentage !== null ||
        historyShowLateBloomerOnly ||
        historyShowOldCreationOnly ||
        !historyShowPumpFunOnly ||
        !historyShowRaydiumOnly ||
        !historyShowMeteoraOnly;
    
    if (isAnyFilterActive) {
        filterButton.classList.add('active-filter');
        filterButton.style.backgroundColor = 'var(--boost-badge-bg)';
    } else {
        filterButton.classList.remove('active-filter');
        filterButton.style.backgroundColor = '';
    }
}
function enhanceApplyHistoryFiltersWithSource() {
    // Store the original function
    const originalApplyHistoryFilters = applyHistoryFilters;
    
    // Override with new version that includes source filtering
    applyHistoryFilters = function(data) {
        // Call the original function first to apply existing filters
        let filteredData = originalApplyHistoryFilters(data);
        
        // Apply source filtering
        if (!historyShowPumpFunOnly || !historyShowRaydiumOnly || !historyShowMeteoraOnly) {
            filteredData = filteredData.filter(token => {
                // If the token has a source property, use it
                if (token.source) {
                    if (token.source === 'raydium' && !historyShowRaydiumOnly) {
                        return false;
                    }
                    if (token.source === 'meteora' && !historyShowMeteoraOnly) {
                        return false;
                    }
                    if (token.source === 'pumpfun' && !historyShowPumpFunOnly) {
                        return false;
                    }
                    return true;
                }
                
                // For backward compatibility: If source isn't specified, assume PumpFun
                // (since the original data didn't have source info)
                return historyShowPumpFunOnly;
            });
        }
        
        return filteredData;
    };
    
    console.log('Enhanced applyHistoryFilters with source filtering');
}

// Function to enhance applyHistoryFilters with classification filtering
function enhanceApplyHistoryFiltersWithClassifications() {
    // Store the original function
    const originalApplyHistoryFilters = applyHistoryFilters;
    
    // Override with new version that includes classification filtering
    applyHistoryFilters = function(data) {
        // Call the original function first to apply existing filters
        let filteredData = originalApplyHistoryFilters(data);
        
        // Apply classification filtering
        filteredData = filteredData.filter(token => {
            return tokenMatchesClassificationFilters(token.token_address);
        });
        
        return filteredData;
    };
    
    console.log('Enhanced applyHistoryFilters with classification filtering');
}

        // Function to enhance the filter logic
        function enhanceApplyHistoryFilters() {
            // Store the original function
            const originalApplyHistoryFilters = applyHistoryFilters;
            
            // Override with our enhanced version
            applyHistoryFilters = function(data) {
                // Call the original function first to apply existing filters
                let filteredData = originalApplyHistoryFilters(data);
                
                // Apply SUS% range filter if values are set
                if (historyMinSusPercentage !== null || historyMaxSusPercentage !== null) {
                    filteredData = filteredData.filter(token => {
                        const susPercentage = getTokenSusPercentage(token);
                        
                        // Apply minimum if set
                        if (historyMinSusPercentage !== null && susPercentage < historyMinSusPercentage) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxSusPercentage !== null && susPercentage > historyMaxSusPercentage) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                // Apply DEV% range filter if values are set
                if (historyMinDevPercentage !== null || historyMaxDevPercentage !== null) {
                    filteredData = filteredData.filter(token => {
                        const devPercentage = getTokenDevPercentage(token);
                        
                        // Apply minimum if set
                        if (historyMinDevPercentage !== null && devPercentage < historyMinDevPercentage) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxDevPercentage !== null && devPercentage > historyMaxDevPercentage) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                // Apply INSIDER% range filter if values are set
                if (historyMinInsiderPercentage !== null || historyMaxInsiderPercentage !== null) {
                    filteredData = filteredData.filter(token => {
                        const insiderPercentage = getTokenInsiderPercentage(token);
                        
                        // Apply minimum if set
                        if (historyMinInsiderPercentage !== null && insiderPercentage < historyMinInsiderPercentage) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxInsiderPercentage !== null && insiderPercentage > historyMaxInsiderPercentage) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                return filteredData;
            };
            
            console.log('Enhanced applyHistoryFilters to include SUS%, DEV%, and INSIDER% filtering');
        }

        // 3. Modify the applyHistoryFilters function to include market cap, token age, and FARM% range filtering
        function updateApplyHistoryFilters() {
            // Store the original function
            const originalApplyHistoryFilters = applyHistoryFilters;
            
            // Override with new version that includes all filters
            applyHistoryFilters = function(data) {
                // Call the original function first to apply existing filters
                let filteredData = originalApplyHistoryFilters(data);
                
                // Apply market cap range filter if values are set
                if (historyMinMarketCap !== null || historyMaxMarketCap !== null) {
                    filteredData = filteredData.filter(token => {
                        const marketCap = token.usd_market_cap || 0;
                        
                        // Apply minimum if set
                        if (historyMinMarketCap !== null && marketCap < historyMinMarketCap) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxMarketCap !== null && marketCap > historyMaxMarketCap) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                // Apply token age range filter if values are set
                if (historyMinTokenAge !== null || historyMaxTokenAge !== null) {
                    filteredData = filteredData.filter(token => {
                        if (!token.timestamp) return false;
                        
                        // Calculate token age in minutes
                        const now = new Date();
                        const tokenTimestamp = new Date(token.timestamp);
                        const ageInMinutes = Math.floor((now - tokenTimestamp) / (1000 * 60));
                        
                        // Apply minimum if set
                        if (historyMinTokenAge !== null && ageInMinutes < historyMinTokenAge) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxTokenAge !== null && ageInMinutes > historyMaxTokenAge) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                // Apply FARM% range filter if values are set
                if (historyMinFarmPercentage !== null || historyMaxFarmPercentage !== null) {
                    filteredData = filteredData.filter(token => {
                        const farmPercentage = getTokenFarmPercentage(token);
                        
                        // Apply minimum if set
                        if (historyMinFarmPercentage !== null && farmPercentage < historyMinFarmPercentage) {
                            return false;
                        }
                        
                        // Apply maximum if set
                        if (historyMaxFarmPercentage !== null && farmPercentage > historyMaxFarmPercentage) {
                            return false;
                        }
                        
                        return true;
                    });
                }
                
                return filteredData;
            };
            
            console.log('Modified applyHistoryFilters to include market cap and token age range filtering');
        }

// Also update the CSS styles for consistency
function addActiveFilterStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .filter-dropdown-button.active-filter {
            background-color: var(--boost-badge-bg);
        }
        
        .filter-section-header {
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            padding: 0 16px;
            color: var(--header-color);
        }
        
        .market-cap-range-container {
            padding: 5px 16px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .market-cap-range-container input {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--widget-bg);
            color: var(--text-color);
        }
        
        .market-cap-range-container input::placeholder {
            color: var(--subtext-color);
            opacity: 0.7;
        }
        
        .market-cap-range-container button {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        
        #historyApplyMarketCapRange {
            background-color: var(--badge-bg);
            color: var(--badge-color);
            font-weight: bold;
        }
        
        #historyClearMarketCapRange {
            background-color: var(--copy-bg);
            color: var(--text-color);
        }
    `;
    document.head.appendChild(styleElement);
        }

// Function to add CSS styles for the highest threshold column
function addHighestThresholdStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .highest-threshold-col {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 5px;
            text-align: center;
        }
        
        .highest-threshold-value {
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--header-color);
        }
        
        .highest-threshold-label {
            font-size: 0.65rem;
            color: var(--subtext-color);
        }
        
        #sort-history-threshold {
            display: flex;
            justify-content: center;
            width: 100%;
            cursor: pointer;
            position: relative;
            padding-right: 15px;
        }
        
        #sort-history-threshold:after {
            content: "↕";
            position: relative;
            opacity: 0.5;
            margin-left: 3px;
        }
        
        #sort-history-threshold.asc:after {
            content: "↑";
            opacity: 1;
        }
        
        #sort-history-threshold.desc:after {
            content: "↓";
            opacity: 1;
        }
        
        /* Responsive styling */
        @media (max-width: 768px) {
            /* Push market cap column more to the right */
            #history-widget .token-header,
            #history-widget .token-row {
                /* Adjust column distribution - give more weight to scan history and less to token */
                grid-template-columns: 40px minmax(120px, 1.2fr) minmax(120px, 1.7fr) 80px !important;
            }
            
            /* Add left padding to create more space between scan history and market cap */
            .marketcap-col {
                padding-left: 8px;
                justify-self: end; /* Right-align the market cap column */
            }
            
            /* Ensure market cap text aligns properly */
            .marketcap-value, .marketcap-label {
                text-align: right;
            }
            
            /* Reduce padding in history column to allow more space overall */
            .token-history-col {
                padding: 0 2px;
            }
                /* Hide the token symbol completely */
            .token-symbol {
                display: none;
            }
        }
            
        }
    `;
    document.head.appendChild(styleElement);
    console.log('Added CSS styles for the Highest Threshold column');
}

        // 5. Update existing filter indicators to show when they're active
        function updateExistingFilterIndicators() {
            // Get references to the checkboxes
            const socialLinksCheckbox = document.getElementById('historyHasSocialLinks');
            const excludeFarmCheckbox = document.getElementById('historyExcludeFarmTokens');
            const dexPaidCheckbox = document.getElementById('historyShowDexPaidOnly');
            
            // Helper function to update the filter button state
            function updateFilterButtonState() {
                const filterButton = document.getElementById('historyFilterButton');
                if (!filterButton) return;
                
                const isAnyFilterActive = 
                    historyFilterSocialLinks || 
                    historyExcludeFarmTokens || 
                    historyShowDexPaidOnly ||
                    historyMinMarketCap !== null ||
                    historyMaxMarketCap !== null ||
                    historyMinTokenAge !== null ||
                    historyMaxTokenAge !== null ||
                    historyMinFarmPercentage !== null ||
                    historyMaxFarmPercentage !== null ||
                    historyShowLateBloomerOnly ||
                    historyShowOldCreationOnly ||
                    !historyShowPumpFunOnly ||
                    !historyShowRaydiumOnly ||
                    !historyShowMeteoraOnly ||
                    !historyShowMemecoin ||
                    !historyShowUtility ||
                    !historyShowAiToken ||
                    !historyShowTweetCoin ||
                    !historyShowCurrentEvent ||
                    !historyShowRacist ||
                    !historyShowOffensive ||
                    !historyShowAnimals ||
                    !historyShowPolitical;
                
                if (isAnyFilterActive) {
                    filterButton.classList.add('active-filter');
                    filterButton.style.backgroundColor = 'var(--boost-badge-bg)';
                } else {
                    filterButton.classList.remove('active-filter');
                    filterButton.style.backgroundColor = '';
                }
            }
            
            // Add change listeners to update filter button appearance
            if (socialLinksCheckbox) {
                const originalListener = socialLinksCheckbox.onchange;
                socialLinksCheckbox.onchange = function(e) {
                    if (originalListener) originalListener.call(this, e);
                    updateFilterButtonState();
                };
            }
            
            if (excludeFarmCheckbox) {
                const originalListener = excludeFarmCheckbox.onchange;
                excludeFarmCheckbox.onchange = function(e) {
                    if (originalListener) originalListener.call(this, e);
                    updateFilterButtonState();
                };
            }
            
            if (dexPaidCheckbox) {
                const originalListener = dexPaidCheckbox.onchange;
                dexPaidCheckbox.onchange = function(e) {
                    if (originalListener) originalListener.call(this, e);
                    updateFilterButtonState();
                };
            }
            
            // Initialize the filter button state
            updateFilterButtonState();
        }

        // 6. Function to apply all market cap range filter changes
        function applyMarketCapRangeFilterChanges() {
            // Add the new filter UI elements
            addMarketCapRangeFilter();
            
            // Update the filter function
            updateApplyHistoryFilters();
            
            // Add the required CSS
            addActiveFilterStyles();
            
            // Also update the active filter indicator logic for existing filters
            updateExistingFilterIndicators();
            
            console.log('Market cap range filter implementation complete');
        }

        // Function to apply all additional metric filters
        function applyAdditionalMetricFilters() {
            // Add the new filter UI elements
            enhanceMarketCapRangeFilter();
            
            // Update the filter function
            enhanceApplyHistoryFilters();
            
            console.log('Additional metrics filter implementation complete');
        }


        // If the document is already loaded, apply the changes immediately
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(applyMarketCapRangeFilterChanges, 700);
            setTimeout(applyAdditionalMetricFilters, 800);
        }

// 1. Format journey history function with color-coded tags
// Update the formatJourneyHistory function to use parseMetricValue
function formatJourneyHistory(tokenAddress) {
    // Check if this token has an incomplete scan
    const isIncomplete = hasIncompleteScan(tokenAddress);

    if (isIncomplete) {
        // Create a "Scan in Progress" tag to add at the beginning
        const scanInProgressTag = `
            <div class="history-item" style="order: -1;">
                <span class="history-tag" style="background-color: #9b59b6; color: white;">Scan in Progress</span>
                <span class="history-timestamp">Current Status</span>
            </div>
        `;
        
        // We'll add this to the beginning of the journey history later
        var scanInProgressHTML = scanInProgressTag;
    }
    // Look up the token's threshold data
    const thresholdData = tokenThresholdsMap[tokenAddress];
    
    // Find the token in graduated_tokens_log.json to get its timestamp
    let logToken = currentGraduatedLogData.find(token => token.token_address === tokenAddress);

    // If not found in PumpFun log, check in Raydium graduated tokens log
    if (!logToken && currentGraduatedBonkLogData) {
        logToken = currentGraduatedBonkLogData.find(token => token.token_address === tokenAddress);
    }

    // If not found in PumpFun or Raydium log, check in Meteora graduated tokens log
    if (!logToken && currentGraduatedMeteoraLogData) {
        logToken = currentGraduatedMeteoraLogData.find(token => token.token_address === tokenAddress);
    }

    
    const graduatedTimestamp = logToken ? logToken.timestamp : null;
    
    // If there's no journey history data, create a Migration tag with SUS%
    if (!thresholdData || !thresholdData.journey_history || thresholdData.journey_history.length === 0) {
        // Get SUS% from the token data
        let susPercentage = 0;
        
        // Try to get SUS% from currentGraduatedLogData first
        if (logToken) {
            // Use the same calculation logic as elsewhere in the app
            const bundles = parseMetricValue(logToken.bundles);
            const freshWallets = parseMetricValue(logToken.fresh_wallets);
            const holders = parseMetricValue(logToken.holders);
            const clusters = parseMetricValue(logToken.clusters);
            
            susPercentage = Math.max(bundles, freshWallets, holders, clusters);
        }
        
        // If we still have no SUS%, check if we have threshold data with all_time_sus_wallets
        if (susPercentage === 0 && thresholdData && thresholdData.all_time_sus_wallets !== undefined) {
            susPercentage = parseMetricValue(thresholdData.all_time_sus_wallets);
        }

        // Get and format market cap from the logToken
        let marketCapText = '';
        if (logToken && logToken.usd_market_cap) {
            const marketCap = Math.round(logToken.usd_market_cap);
            if (marketCap >= 1000000) {
                marketCapText = ` $${(marketCap / 1000000).toFixed(2)}M`;
            } else if (marketCap >= 1000) {
                marketCapText = ` $${(marketCap / 1000).toFixed(0)}K`;
            } else {
                marketCapText = ` $${marketCap}`;
            }
        }
        
        // Create a blue Migration tag with SUS%
        const tagColor = '#1b3f20'; // Blue
        const textColor = 'white';
        
        // Also add farm status if available
        const farmStatus = thresholdData ? thresholdData.farm_status : null;
        let farmStatusHtml = '';

        if (farmStatus) {
            // Check if this token has fake distribution
            const hasFakeDistrib = hasFakeDistribution(tokenAddress);
            
            // Set color based on fake distribution status
            const farmStatusColor = hasFakeDistrib ? 
                '#8B008B' : // Magenta if fake distribution
                'var(--farm-label-bg)';
            
            const farmStatusTextColor = 'var(--farm-label-color)';
            
            farmStatusHtml = `<span class="history-farm-status" style="background-color: ${farmStatusColor}; color: ${farmStatusTextColor};">${farmStatus}</span>`;
        }
        
        // Format time since using the graduated timestamp (if available)
        let timeSinceText = 'N/A';
        if (graduatedTimestamp) {
            timeSinceText = formatTimeSince(graduatedTimestamp);
        }
        
        return `<div class="history-item">
                    <span class="history-tag" style="background-color: ${tagColor}; color: ${textColor};">${susPercentage.toFixed(1)}%${marketCapText}</span>
                    ${farmStatusHtml}
                    <span class="history-timestamp">${timeSinceText}</span>
                </div>`;
    }
    
    // Sort the journey history by timestamp (if available)
    const history = [...thresholdData.journey_history].sort((a, b) => {
        // For Dex Paid entries, use dex_paid_timestamp instead of timestamp
        const aTimestamp = a.scan_reason === "Dex Paid" ? a.dex_paid_timestamp : a.timestamp;
        const bTimestamp = b.scan_reason === "Dex Paid" ? b.dex_paid_timestamp : b.timestamp;
        
        // Handle cases where either entry doesn't have the appropriate timestamp
        if (!aTimestamp && !bTimestamp) return 0;
        if (!aTimestamp) return -1;
        if (!bTimestamp) return 1;
        
        const timeA = new Date(aTimestamp).getTime();
        const timeB = new Date(bTimestamp).getTime();
        return timeA - timeB;
    });
    
    // Define color mapping for different scan reasons
    const scanReasonColors = {
        'Migration': '#1b3f20',        // Green
        'First Scan': '#28355a',       // Blue
        'Rescan': '#393939',           // Gray
        'Threshold Scan': '#4d2d4b',   // Purple
        'Dex Paid': '#0e0e0e',         // Black
        'Unknown': '#7f8c8d'           // Dark Gray
    };

    // Process the sorted history to consolidate rescans
    const processedHistory = [];
    let rescanSequence = [];
    let prevEntry = null;
    
    for (let i = 0; i < history.length; i++) {
        const entry = history[i];
        const scanReason = entry.scan_reason || 'Unknown';
        
        if (scanReason === 'Rescan') {
            // Add to the rescan sequence
            rescanSequence.push(entry);
        } else {
            // If we have a rescan sequence and now encountered a non-rescan entry
            if (rescanSequence.length > 0) {
                // Add an ellipsis entry to indicate multiple rescans
                if (rescanSequence.length > 1) {
                    // Find the last rescan where farm_status changed, if any
                    let statusChangeRescan = null;
                    let prevStatus = prevEntry ? prevEntry.farm_status : null;
                    
                    for (let j = 0; j < rescanSequence.length; j++) {
                        if (rescanSequence[j].farm_status !== prevStatus) {
                            statusChangeRescan = rescanSequence[j];
                            prevStatus = rescanSequence[j].farm_status;
                        }
                    }
                    
                    // Add the appropriate rescan entry
                    if (statusChangeRescan) {
                        // Add the last one where status changed
                        processedHistory.push({
                            type: 'ellipsis'
                        });
                        processedHistory.push(statusChangeRescan);
                    } else {
                        // Add the most recent rescan
                        processedHistory.push({
                            type: 'ellipsis'
                        });
                        processedHistory.push(rescanSequence[rescanSequence.length - 1]);
                    }
                } else {
                    // Only one rescan, add it directly
                    processedHistory.push(rescanSequence[0]);
                }
                
                // Reset the rescan sequence
                rescanSequence = [];
            }
            
            // Add the current non-rescan entry
            processedHistory.push(entry);
        }
        
        prevEntry = entry;
    }
    
    // Handle any remaining rescans at the end
    if (rescanSequence.length > 0) {
        if (rescanSequence.length > 1) {
            // Find the last rescan where farm_status changed, if any
            let statusChangeRescan = null;
            let prevStatus = prevEntry ? prevEntry.farm_status : null;
            
            for (let j = 0; j < rescanSequence.length; j++) {
                if (rescanSequence[j].farm_status !== prevStatus) {
                    statusChangeRescan = rescanSequence[j];
                    prevStatus = rescanSequence[j].farm_status;
                }
            }
            
            // Add the appropriate rescan entry
            if (statusChangeRescan) {
                // Add the last one where status changed
                processedHistory.push({
                    type: 'ellipsis'
                });
                processedHistory.push(statusChangeRescan);
            } else {
                // Add the most recent rescan
                processedHistory.push({
                    type: 'ellipsis'
                });
                processedHistory.push(rescanSequence[rescanSequence.length - 1]);
            }
        } else {
            // Only one rescan, add it directly
            processedHistory.push(rescanSequence[0]);
        }
    }
    
    // Format each entry
    const formattedEntries = processedHistory.map(entry => {
        // Handle ellipsis entry
        if (entry.type === 'ellipsis') {
            return `
                <div class="history-item">
                    <span class="history-tag" style="background-color: #7f8c8d; color: white;">Rescanning...</span>
                </div>
            `;
        }
        
        const scanReason = entry.scan_reason || 'Unknown';
        
        // Get highest_sus_wallets if available and ensure it's properly parsed
        let susWallets = '';
        if (entry.highest_sus_wallets !== undefined) {
            // Use parseMetricValue to handle cases like "No Results"
            const susValue = parseMetricValue(entry.highest_sus_wallets);
            susWallets = ` ${susValue.toFixed(1)}%`;
        }
        
        // Use threshold if available, otherwise use usd_market_cap if available
        let threshold = '';
        if (entry.threshold) {
            // Format as 1M instead of 1000K when threshold >= 1,000,000
            if (entry.threshold >= 1000000) {
                threshold = ` $${(entry.threshold / 1000000).toFixed(2)}M`;
            } else {
                threshold = ` $${(entry.threshold / 1000).toFixed(0)}K`;
            }
        } else if (entry.usd_market_cap) {
            const marketCap = Math.round(entry.usd_market_cap);
            if (marketCap >= 1000000) {
                threshold = ` $${(marketCap / 1000000).toFixed(2)}M`;
            } else if (marketCap >= 1000) {
                threshold = ` $${(marketCap / 1000).toFixed(0)}K`;
            } else {
                threshold = ` $${marketCap}`;
            }
        }
        
        // Get the color for this scan reason
        const tagColor = scanReasonColors[scanReason] || scanReasonColors['Unknown'];
        
        // Calculate text color based on background brightness
        const isLightBackground = ['#2ecc71', '#95a5a6'].includes(tagColor);
        const textColor = isLightBackground ? 'white' : 'white';
        
        // Get the timestamp based on scan reason and handle Migration specially
        let timestamp;
        let isDexPaid = false; // Add this flag
        
        if (scanReason === "Migration" && graduatedTimestamp) {
            // For Migration, use the timestamp from graduated_tokens_log.json
            timestamp = graduatedTimestamp;
        } else if (scanReason === "Dex Paid") {
            // For Dex Paid, use dex_paid_timestamp and set the flag
            timestamp = entry.dex_paid_timestamp;
            isDexPaid = true; // Set the flag for Dex Paid entries
        } else {
            // For all other entries, use the entry's timestamp
            timestamp = entry.timestamp;
        }
        
        // Format time since - pass the isDexPaid flag
        let timeSinceText = 'N/A';
        if (timestamp) {
            timeSinceText = formatTimeSince(timestamp, isDexPaid);
        }
        
        // Extract and format farm status from the entry
        let farmStatusHtml = '';
        if (entry.farm_status) {
            // Check for fake distribution in this specific entry
            const hasFakeDistrib = entry.fake_distribution === true;
            
            // Set color based on farm status and fake distribution
            let farmStatusColor;
            if (hasFakeDistrib) {
                farmStatusColor = '#8B008B'; // Magenta if fake distribution
            } else if (entry.farm_status === 'FARM') {
                farmStatusColor = 'var(--farm-label-bg)'; // Red for FARM
            } else if (entry.farm_status === 'FARMED') {
                farmStatusColor = 'var(--farmed-label-bg)'; // Yellow for FARMED
            } else if (entry.farm_status === 'NO FARM DETECTED') {
                farmStatusColor = 'var(--no-farm-label-bg)'; // Green for NO FARM
            } else {
                farmStatusColor = 'var(--farm-label-bg)'; // Default to red for unknown statuses
            }
            
            const farmStatusTextColor = 'var(--farm-label-color)';
            
            farmStatusHtml = `<span class="history-farm-status" style="background-color: ${farmStatusColor}; color: ${farmStatusTextColor};">${entry.farm_status}</span>`;
        }
        
        // Determine tag text based on scan reason
        let tagText;
        if (scanReason === "Dex Paid") {
            // For Dex Paid, just show "Dex Paid" without sus% or threshold
            tagText = "Dex Paid";
        } else {
            // For all other scan reasons, keep the original format with sus% and threshold
            tagText = `${susWallets}${threshold}`;
        }
        
        // Create a container div for the tag, farm status, and timestamp
        return `
            <div class="history-item">
                <span class="history-tag" style="background-color: ${tagColor}; color: ${textColor};">${tagText}</span>
                ${farmStatusHtml}
                <span class="history-timestamp">${timeSinceText}</span>
            </div>
        `;
    });
    
    // If token has an incomplete scan, add the scan in progress indicator at the beginning
    if (isIncomplete && scanInProgressHTML) {
        return scanInProgressHTML + formattedEntries.join('');
    }
    return formattedEntries.join('');
}


// 2. Create history token row with Token History column
function createHistoryTokenRow(token) {
    // Get the base row from the original function
    const row = createGraduatedTokenRow(token);
    
    // Check if we're on mobile (under 480px)
    const isMobile = window.innerWidth <= 480;
    
    // Update the grid template based on screen size
    if (isMobile) {
        // Mobile layout (4 columns, no highest threshold column)
        row.style.gridTemplateColumns = '40px minmax(100px, 1fr) minmax(100px, 1.5fr) 70px';
    } else {
        // Desktop layout (5 columns with highest threshold)
        row.style.gridTemplateColumns = '40px minmax(120px, 1fr) minmax(150px, 2fr) 100px 80px';
    }
    
    // Create token history column
    const tokenHistoryCol = document.createElement('div');
    tokenHistoryCol.className = 'token-history-col';
    
    // Format and set the journey history
    const journeyHistory = formatJourneyHistory(token.token_address);
    tokenHistoryCol.innerHTML = journeyHistory;
    
    // Create highest threshold column
    const highestThresholdCol = document.createElement('div');
    highestThresholdCol.className = 'highest-threshold-col';
    highestThresholdCol.style.display = 'flex';
    highestThresholdCol.style.flexDirection = 'column';
    highestThresholdCol.style.justifyContent = 'center';
    highestThresholdCol.style.alignItems = 'center';
    highestThresholdCol.style.padding = '0 5px';
    
    // Get and format the highest threshold
    const highestThreshold = formatHighestThreshold(token.token_address);
    
    // Create the highest threshold value element with styling
    const thresholdValueEl = document.createElement('div');
    thresholdValueEl.className = 'highest-threshold-value';
    thresholdValueEl.textContent = highestThreshold;
    thresholdValueEl.style.fontWeight = 'bold';
    thresholdValueEl.style.fontSize = '0.85rem';
    thresholdValueEl.style.color = 'var(--header-color)';
    
    // Create the label element
    const thresholdLabelEl = document.createElement('div');
    thresholdLabelEl.className = 'highest-threshold-label';
    thresholdLabelEl.textContent = 'Threshold';
    thresholdLabelEl.style.fontSize = '0.65rem';
    thresholdLabelEl.style.color = 'var(--subtext-color)';
    
    // Add elements to the column
    highestThresholdCol.appendChild(thresholdValueEl);
    highestThresholdCol.appendChild(thresholdLabelEl);
    
    // Add data attribute for sorting
    if (tokenThresholdsMap[token.token_address] && 
        tokenThresholdsMap[token.token_address].all_time_highest_threshold !== undefined) {
        row.dataset.highestThreshold = tokenThresholdsMap[token.token_address].all_time_highest_threshold;
    } else {
        row.dataset.highestThreshold = '0';
    }
    
    // Insert columns in the correct order
    const marketCapCol = row.querySelector('.marketcap-col');
    row.insertBefore(tokenHistoryCol, marketCapCol);
    
    // Only add highest threshold column on non-mobile
    if (!isMobile) {
        row.insertBefore(highestThresholdCol, marketCapCol);
    }
    
    // Check if this token has an incomplete scan
    const isIncomplete = hasIncompleteScan(token.token_address);

    if (isIncomplete) {
        // Remove farm-token class if it exists
        row.classList.remove('farm-token');
        
        // Add incomplete-scan-token class
        row.classList.add('incomplete-scan-token');
    }


    // Add source badge
    const tokenInfoContainer = row.querySelector('.token-info-container');
    if (tokenInfoContainer) {
        // Determine the token source
        // Determine the token source
        let sourceBadge;
        if (token.source === 'raydium') {
            // Create Raydium badge
            sourceBadge = document.createElement('span');
            sourceBadge.className = 'source-badge raydium-badge';
            sourceBadge.textContent = 'Raydium';
            sourceBadge.style.display = 'inline-block';
            sourceBadge.style.backgroundColor = '#00c2ff';
            sourceBadge.style.color = '#000000';
            sourceBadge.style.padding = '1px 5px';
            sourceBadge.style.borderRadius = '3px';
            sourceBadge.style.fontSize = '0.55rem';
            sourceBadge.style.fontWeight = 'bold';
            sourceBadge.style.marginLeft = '5px';
        } else if (token.source === 'meteora') {
            // Create Meteora badge
            sourceBadge = document.createElement('span');
            sourceBadge.className = 'source-badge meteora-badge';
            sourceBadge.textContent = 'Meteora';
            sourceBadge.style.display = 'inline-block';
            sourceBadge.style.backgroundColor = '#9370DB';
            sourceBadge.style.color = '#ffffff';
            sourceBadge.style.padding = '1px 5px';
            sourceBadge.style.borderRadius = '3px';
            sourceBadge.style.fontSize = '0.55rem';
            sourceBadge.style.fontWeight = 'bold';
            sourceBadge.style.marginLeft = '5px';
        } else {
            // Create PumpFun badge (for original tokens or explicitly marked as PumpFun)
            sourceBadge = document.createElement('span');
            sourceBadge.className = 'source-badge pumpfun-badge';
            sourceBadge.textContent = 'PumpFun';
            sourceBadge.style.display = 'inline-block';
            sourceBadge.style.backgroundColor = '#4CAF50';
            sourceBadge.style.color = '#ffffff';
            sourceBadge.style.padding = '1px 5px';
            sourceBadge.style.borderRadius = '3px';
            sourceBadge.style.fontSize = '0.55rem';
            sourceBadge.style.fontWeight = 'bold';
            sourceBadge.style.marginLeft = '5px';
        }
        
        // Add the badge after the token name
        tokenInfoContainer.appendChild(sourceBadge);
    }
    return row;
}

// 3. Override renderHistoryTokensList function to use our new row creator
const originalRenderHistoryTokensList = renderHistoryTokensList;
renderHistoryTokensList = function(data) {
    // Apply filters
    let filteredData = applyHistoryFilters(data);
    
    // Clear tokens list
    const tokensList = document.getElementById('history-tokens-list');
    tokensList.innerHTML = '';
    
    if (filteredData.length === 0) {
        tokensList.innerHTML = '<div class="empty-state">No tokens found matching your filters</div>';
        return;
    }
    
    // Create and append token rows using our new function
    filteredData.forEach(token => {
        const row = createHistoryTokenRow(token);
        tokensList.appendChild(row);
    });
};

// 4. Function to update the history widget header
function updateHistoryWidgetHeader() {
    const tokenHeader = document.querySelector('#history-widget .token-header');
    if (!tokenHeader) return;
    
    // Check if we're on mobile
    const isMobile = window.innerWidth <= 480;
    
    // Update the grid template based on screen size
    if (isMobile) {
        // Mobile layout (4 columns, no highest threshold)
        tokenHeader.style.gridTemplateColumns = '40px minmax(100px, 1fr) minmax(100px, 1.5fr) 70px';
        
        // Update the header content for mobile
        tokenHeader.innerHTML = `
            <div class="sortable" id="sort-history-timestamp"></div>
            <div>Token</div>
            <div>Scan History</div>
            <div class="marketcap-col sortable" id="sort-history-market-cap">MC</div>
        `;
    } else {
        // Desktop layout (5 columns with highest threshold)
        tokenHeader.style.gridTemplateColumns = '40px minmax(120px, 1fr) minmax(150px, 2fr) 100px 80px';
        
        // Rebuild the header content for desktop
        tokenHeader.innerHTML = `
            <div class="sortable" id="sort-history-timestamp"></div>
            <div>Token</div>
            <div>Scan History</div>
            <div class="sortable" id="sort-history-threshold">Highest</div>
            <div class="marketcap-col sortable" id="sort-history-market-cap">MC</div>
        `;
    }
    
    // Re-attach event listeners
    document.getElementById('sort-history-timestamp').addEventListener('click', handleHistoryTimestampSort);
    document.getElementById('sort-history-market-cap').addEventListener('click', handleHistoryMarketCapSort);
    
    // Add event listener for highest threshold sorting (only on desktop)
    if (!isMobile) {
        document.getElementById('sort-history-threshold').addEventListener('click', handleHistoryThresholdSort);
    }
}

// 5. Function to apply all changes
function applyTokenHistoryChanges() {
    // Update the history widget header
    updateHistoryWidgetHeader();
    
    // Re-render the history tokens list if data is available
    if (currentHistoryData && currentHistoryData.length > 0) {
        renderHistoryTokensList(currentHistoryData);
    }
    
    console.log('Token History column added to Graduated Token History widget');
}



// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyTokenHistoryChanges, 1000);
}

// Function to apply history timestamp changes
function applyHistoryTimestampChanges() {
    // Re-render the history list if data is available
    if (currentHistoryData && currentHistoryData.length > 0) {
        renderHistoryTokensList(currentHistoryData);
    }
    
    console.log('Token History timestamps added to Graduated Token History widget');
}



// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyHistoryTimestampChanges, 1200);
}
// Function to apply the token history farm status changes
function applyTokenHistoryFarmStatusChanges() {
    // Add the CSS styles for farm status tags
    addFarmStatusStyles();
    
    // Re-render the history tokens list if data is available
    if (currentHistoryData && currentHistoryData.length > 0) {
        renderHistoryTokensList(currentHistoryData);
    }
    
    console.log('Farm status tags added to Token History entries');
}
// Function to apply all changes
function applyRescanConsolidationChanges() {
    // Add the ellipsis styles
    addEllipsisStyles();
    
    // Re-render the history tokens list
    if (currentHistoryData && currentHistoryData.length > 0) {
        renderHistoryTokensList(currentHistoryData);
    }
    
    console.log('Applied rescan consolidation changes to Token History column');
}



// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyTokenHistoryFarmStatusChanges, 1300);
}

// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyRescanConsolidationChanges, 1500);
}

// Updated function to fix dropdown positioning
function fixFilterDropdownPosition() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* Position the dropdown container to allow for proper dropdown placement */
        .filter-dropdown-container {
            position: relative;
        }
        
        /* Make the dropdown position absolute and ensure it's not constrained */
        .filter-dropdown-content {
            position: absolute;
            right: 0;
            top: 100%;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 300px; /* Fixed width to accommodate all filter options */
        }
        
        /* Ensure parent containers don't clip the dropdown */
        #history-widget .widget-header-container,
        #history-widget .widget-header,
        .filter-dropdown-container {
            overflow: visible !important;
        }
        
        /* Widget container must allow overflow */
        #history-widget {
            overflow: visible !important;
        }
        
        /* Apply these styles to all relevant parent containers */
        .widget, .widgets-row, .container {
            overflow: visible !important;
        }
        
        /* Style the scrollbar */
        .filter-dropdown-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .filter-dropdown-content::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }
        
        .filter-dropdown-content::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 3px;
        }
    `;
    document.head.appendChild(styleElement);
    console.log('Fixed filter dropdown positioning');
}

// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(fixFilterDropdownPosition, 1700);
}
// Function to apply all highest threshold column changes
function applyHighestThresholdChanges() {
    // Add the CSS styles
    addHighestThresholdStyles();
    
    // Update the history widget header
    updateHistoryWidgetHeader();
    
    // Re-render the history tokens list if data is available
    if (currentHistoryData && currentHistoryData.length > 0) {
        renderHistoryTokensList(currentHistoryData);
    }
    
    console.log('Highest Threshold column added to Graduated Token History widget');
}


// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyHighestThresholdChanges, 2000);
}


// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(applyThresholdStatsToggleChanges, 2100);
}
// Apply incomplete scan highlighting when the page loads
setTimeout(function() {
    console.log('Applying initial incomplete scan highlighting');
    const allTokenRows = document.querySelectorAll('.token-row, .token-row-with-boost');
    allTokenRows.forEach(row => {
        // Extract token address
        const copyIcon = row.querySelector('.copy-icon');
        if (!copyIcon) return;
        
        const tokenAddress = copyIcon.getAttribute('data-address');
        if (!tokenAddress) return;
        
        // Check if this token has an incomplete scan
        const isIncomplete = hasIncompleteScan(tokenAddress);
        
        if (isIncomplete) {
            // Remove farm-token class if it exists
            row.classList.remove('farm-token');
            
            // Add incomplete-scan-token class
            row.classList.add('incomplete-scan-token');
            
        }
    });
}, 2500); // Wait for all other initializations to complete

// Function to add the checkbox to the Threshold Stats widget header
function addThresholdStatsToggle() {
    // Find the widget header
    const widgetHeader = document.querySelector('#threshold-stats-widget .widget-header');
    
    if (!widgetHeader) {
        console.error('Threshold stats widget header not found');
        return;
    }
    
    // Create the filter control div
    const filterControl = document.createElement('div');
    filterControl.className = 'filter-control';
    
    // Create the checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = 'showUnfilteredStats';
    checkbox.name = 'showUnfilteredStats';
    
    // Create the label
    const label = document.createElement('label');
    label.htmlFor = 'showUnfilteredStats';
    label.textContent = 'Inlcude FARMS';
    label.style.marginLeft = '5px';
    
    // Add checkbox and label to the filter control
    filterControl.appendChild(checkbox);
    filterControl.appendChild(label);
    
    // Insert the filter control before the last child (the last_updated span)
    const statusElement = widgetHeader.querySelector('.status');
    if (statusElement) {
        widgetHeader.insertBefore(filterControl, statusElement);
    } else {
        widgetHeader.appendChild(filterControl);
    }
    
    // Add event listener to the checkbox
    checkbox.addEventListener('change', function(e) {
        showUnfilteredStats = e.target.checked;
        
        // Update the stats widget with current data
        if (currentDashboardStatsData) {
            updateStatsWidget(currentDashboardStatsData);
        }
    });
    
    console.log('Added unfiltered stats toggle to Threshold Stats widget');
}
function addHeaderLayoutStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        #history-widget .widget-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        #history-widget .filter-dropdown-container {
            margin-left: auto;
            align-self: flex-start;
        }
        
        #history-widget .history-search-container input {
            width: 220px;
        }
        
        @media (max-width: 768px) {
            #history-widget .history-search-container input {
                width: 160px;
            }
        }
    `;
    document.head.appendChild(styleElement);
    console.log('Added header layout styles');
}

function addSourceBadgeStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .source-badge {
            display: inline-block;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.55rem;
            font-weight: bold;
            margin-left: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .raydium-badge {
            background-color: #00c2ff;
            color: #000000;
        }
        
        .pumpfun-badge {
            background-color: #4CAF50;
            color: #ffffff;
        }
        
        /* Position the badge properly */
        .token-info-container {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        /* Add source filter styles */
        .filter-section-header {
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            padding: 0 16px;
            color: var(--header-color);
        }
        
        #historyFilterDropdown hr {
            margin: 10px 16px;
            border: none;
            border-top: 1px solid var(--border-color);
        }
    `;
    document.head.appendChild(styleElement);
    console.log('Added source badge styles');
}
// Function to add Launch Pad Selector to the Farm Ratio Widget
// Function to add Launch Pad Selector to the Stats Widget
function addLaunchPadSelector() {
    // Find the stats widget header
    const widgetHeader = document.querySelector('#threshold-stats-widget .widget-header');
    
    if (!widgetHeader) {
        console.error('Stats widget header not found');
        return;
    }
    
    // Create a container for the dropdown
    const selectorContainer = document.createElement('div');
    selectorContainer.className = 'launch-pad-selector';
    selectorContainer.style.display = 'flex';
    selectorContainer.style.alignItems = 'center';
    selectorContainer.style.marginTop = '5px';
    selectorContainer.style.marginBottom = '5px';
    
    // Create the label text
    const selectorLabel = document.createElement('span');
    selectorLabel.textContent = '';
    selectorLabel.style.marginRight = '8px';
    selectorLabel.style.fontSize = '0.85rem';
    selectorLabel.style.color = 'var(--text-color)';
    
    // Create the dropdown
    const dropdown = document.createElement('select');
    dropdown.id = 'launch-pad-selector';
    dropdown.style.padding = '4px 8px';
    dropdown.style.borderRadius = '4px';
    dropdown.style.backgroundColor = 'var(--widget-bg)';
    dropdown.style.color = 'var(--text-color)';
    dropdown.style.border = '1px solid var(--border-color)';
    dropdown.style.fontWeight = 'bold';
    dropdown.style.fontSize = '0.85rem';
    dropdown.style.cursor = 'pointer';
    dropdown.style.transition = 'border-color 0.3s ease';
    
    // Add options
    // Add options
    const options = [
        { value: 'combined', text: 'All Launch Pads' },
        { value: 'pumpfun', text: 'PumpFun' },
        { value: 'raydium', text: 'Raydium Launchpad' },
        { value: 'meteora', text: 'Meteora Launchpad' }
    ];
    
    options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.textContent = option.text;
        dropdown.appendChild(optionElement);
    });
    
    // Add event listener
    dropdown.addEventListener('change', function() {
        selectedLaunchPad = this.value;
        
        // Update widgets with selected launch pad data
        if (currentDashboardStatsData) {
            updateStatsWidget(currentDashboardStatsData);
            updateFarmRatioChart(currentDashboardStatsData);
            updateFarmRatioChartTitle(); // Update chart title
        }
    });
    
    // Add label and dropdown to container
    selectorContainer.appendChild(selectorLabel);
    selectorContainer.appendChild(dropdown);
    
    // Find the time toggle container if it exists
    const timeToggleContainer = widgetHeader.querySelector('.time-toggle-container');
    
    // Find or create the header content wrapper
    let headerContentWrapper = widgetHeader.querySelector('div[style*="flex-direction: column"]');
    
    if (!headerContentWrapper) {
        // Create a wrapper div to hold the title and controls
        headerContentWrapper = document.createElement('div');
        headerContentWrapper.style.display = 'flex';
        headerContentWrapper.style.flexDirection = 'column';
        
        // Move the h3 title into our wrapper
        const title = widgetHeader.querySelector('h3');
        if (title) {
            // Clone the title node to avoid moving it
            const titleClone = title.cloneNode(true);
            headerContentWrapper.appendChild(titleClone);
            
            // Replace the original title with our wrapper
            title.parentNode.replaceChild(headerContentWrapper, title);
        } else {
            // If no title found, just insert at the beginning
            widgetHeader.insertBefore(headerContentWrapper, widgetHeader.firstChild);
        }
    }
    
    // Insert the selector container into the wrapper at the appropriate position
    if (timeToggleContainer) {
        // Insert before the time toggle container
        headerContentWrapper.insertBefore(selectorContainer, timeToggleContainer);
    } else {
        // Append to the end if time toggle doesn't exist yet
        headerContentWrapper.appendChild(selectorContainer);
    }
}
// Function to add toggle switch to Threshold Stats widget
function addTimeToggleSwitch() {
    // Find the widget header
    const widgetHeader = document.querySelector('#threshold-stats-widget .widget-header');
    
    if (!widgetHeader) {
        console.error('Threshold stats widget header not found');
        return;
    }
    
    // Create a container for the toggle switch
    const toggleContainer = document.createElement('div');
    toggleContainer.className = 'time-toggle-container';
    toggleContainer.style.display = 'flex';
    toggleContainer.style.alignItems = 'center';
    toggleContainer.style.marginTop = '5px';
    toggleContainer.style.marginBottom = '5px';
    
    // Create the label text
    const toggleLabel = document.createElement('span');
    toggleLabel.textContent = 'Show Last 48 Hrs';
    toggleLabel.style.marginRight = '8px';
    toggleLabel.style.fontSize = '0.85rem';
    toggleLabel.style.color = 'var(--text-color)';
    
    // Create the toggle switch
    const toggleSwitch = document.createElement('label');
    toggleSwitch.className = 'switch';
    toggleSwitch.style.position = 'relative';
    toggleSwitch.style.display = 'inline-block';
    toggleSwitch.style.width = '40px';
    toggleSwitch.style.height = '20px';
    
    // Create the checkbox input
    const toggleInput = document.createElement('input');
    toggleInput.type = 'checkbox';
    toggleInput.id = 'timeToggle';
    toggleInput.style.opacity = '0';
    toggleInput.style.width = '0';
    toggleInput.style.height = '0';
    
    // Create the slider
    const toggleSlider = document.createElement('span');
    toggleSlider.className = 'slider round';
    toggleSlider.style.position = 'absolute';
    toggleSlider.style.cursor = 'pointer';
    toggleSlider.style.top = '0';
    toggleSlider.style.left = '0';
    toggleSlider.style.right = '0';
    toggleSlider.style.bottom = '0';
    toggleSlider.style.backgroundColor = '#ccc';
    toggleSlider.style.transition = '.4s';
    toggleSlider.style.borderRadius = '34px';
    


    // Add the slider before/after styles (for the circle)
    const sliderStyle = document.createElement('style');
    sliderStyle.textContent = `
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--badge-bg);
        }
        
        input:focus + .slider {
            box-shadow: 0 0 1px var(--badge-bg);
        }
        
        input:checked + .slider:before {
            transform: translateX(20px);
        }
    `;
    document.head.appendChild(sliderStyle);
    
    // Assemble the toggle switch
    toggleSwitch.appendChild(toggleInput);
    toggleSwitch.appendChild(toggleSlider);
    
    // Add elements to the container
    toggleContainer.appendChild(toggleLabel);
    toggleContainer.appendChild(toggleSwitch);
    
    // Create a wrapper div to hold the title and toggle
    const headerContentWrapper = document.createElement('div');
    headerContentWrapper.style.display = 'flex';
    headerContentWrapper.style.flexDirection = 'column';
    
    // Move the h3 title into our wrapper
    const title = widgetHeader.querySelector('h3');
    if (title) {
        // Clone the title node to avoid moving it
        const titleClone = title.cloneNode(true);
        headerContentWrapper.appendChild(titleClone);
        
        // Replace the original title with our wrapper
        title.parentNode.replaceChild(headerContentWrapper, title);
    } else {
        // If no title found, just insert at the beginning
        widgetHeader.insertBefore(headerContentWrapper, widgetHeader.firstChild);
    }
    
    // Add the toggle container to the wrapper
    headerContentWrapper.appendChild(toggleContainer);
    
    // Add event listener to the toggle
    toggleInput.addEventListener('change', function() {
        show48HourStats = this.checked;
        
        // Update the widgets with the appropriate time period data
        if (currentDashboardStatsData) {
            updateStatsWidget(currentDashboardStatsData);
            updateFarmRatioChart(currentDashboardStatsData);
        }
        
        // Update title of farm ratio chart
        updateFarmRatioChartTitle();
    });
    
    console.log('Added time period toggle switch to Threshold Stats widget');
}
// Function to apply all threshold stats toggle changes
function applyThresholdStatsToggleChanges() {
    // Add the checkbox to the widget header
    addThresholdStatsToggle();
    
    // Update the widget with current data if available
    if (currentDashboardStatsData) {
        updateStatsWidget(currentDashboardStatsData);
    }
    
    console.log('Applied threshold stats toggle changes');
}
// Function to add color key to the History widget
function addHistoryWidgetColorKey() {
  // Find the widget header
  const widgetHeader = document.querySelector('#history-widget .widget-header');
  
  if (!widgetHeader) {
    console.error('History widget header not found');
    return;
  }
  
  // Create the key container
  const keyContainer = document.createElement('div');
  keyContainer.className = 'history-color-key';
  keyContainer.style.display = 'flex';
  keyContainer.style.alignItems = 'center';
  keyContainer.style.fontSize = '0.7rem';
  keyContainer.style.color = 'var(--subtext-color)';
  keyContainer.style.marginTop = '5px';
  keyContainer.style.marginBottom = '8px';
  
  // Create the FARM color key item
  const farmKeyItem = document.createElement('div');
  farmKeyItem.className = 'key-item';
  farmKeyItem.style.display = 'inline-flex';
  farmKeyItem.style.alignItems = 'center';
  farmKeyItem.style.marginRight = '10px';
  
  const farmColorBox = document.createElement('span');
  farmColorBox.style.display = 'inline-block';
  farmColorBox.style.width = '8px';
  farmColorBox.style.height = '8px';
  farmColorBox.style.backgroundColor = 'var(--farm-bg)';
  farmColorBox.style.marginRight = '4px';
  farmColorBox.style.borderRadius = '2px';
  
  const farmLabel = document.createElement('span');
  farmLabel.textContent = 'FARMS';
  
  farmKeyItem.appendChild(farmColorBox);
  farmKeyItem.appendChild(farmLabel);
  
  // Create the INCOMPLETE SCAN color key item
  const incompleteKeyItem = document.createElement('div');
  incompleteKeyItem.className = 'key-item';
  incompleteKeyItem.style.display = 'inline-flex';
  incompleteKeyItem.style.alignItems = 'center';
  
  const incompleteColorBox = document.createElement('span');
  incompleteColorBox.style.display = 'inline-block';
  incompleteColorBox.style.width = '8px';
  incompleteColorBox.style.height = '8px';
  incompleteColorBox.style.backgroundColor = '#431c52'; // Purple color used for incomplete scans
  incompleteColorBox.style.marginRight = '4px';
  incompleteColorBox.style.borderRadius = '2px';
  
  const incompleteLabel = document.createElement('span');
  incompleteLabel.textContent = 'INCOMPLETE SCANS';
  
  incompleteKeyItem.appendChild(incompleteColorBox);
  incompleteKeyItem.appendChild(incompleteLabel);
  
  // Add key items to container
  keyContainer.appendChild(farmKeyItem);
  keyContainer.appendChild(incompleteKeyItem);
  
  // Create a vertical layout container for the header content
  const headerContentLayout = document.createElement('div');
  headerContentLayout.style.display = 'flex';
  headerContentLayout.style.flexDirection = 'column';
  headerContentLayout.style.flex = '1';
  
  // Get title and search elements
  const title = widgetHeader.querySelector('h3');
  const searchContainer = widgetHeader.querySelector('.history-search-container');
  const filterContainer = widgetHeader.querySelector('.filter-dropdown-container');
  
  // If these elements exist, reorganize them
  if (title) {
    // Clone the title (to avoid moving issues)
    const titleClone = title.cloneNode(true);
    headerContentLayout.appendChild(titleClone);
    
    // Add the key after the title
    headerContentLayout.appendChild(keyContainer);
    
    // If search exists, add it next
    if (searchContainer) {
      // Apply necessary styling to the original search container
      searchContainer.style.width = '100%';
      searchContainer.style.margin = '5px 0';
      searchContainer.style.justifyContent = 'flex-start';
    
      // Move the original search container (with event listeners) to the new layout
      headerContentLayout.appendChild(searchContainer);
    
    // No need to remove the original as we've moved it directly
    }
    
    // Replace the title with our new organized layout
    title.parentNode.replaceChild(headerContentLayout, title);
    
    // Move the filter dropdown to the end if it exists
    if (filterContainer) {
      widgetHeader.appendChild(filterContainer);
    }
  }
  
  console.log('Added color key to History widget in vertical layout');
}



// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  setTimeout(addHistoryWidgetColorKey, 2200);
}



// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(function() {
        addTimeToggleSwitch();
        if (farmRatioChart) updateFarmRatioChartTitle();
        if (currentDashboardStatsData) {
            updateStatsWidget(currentDashboardStatsData);
            updateFarmRatioChart(currentDashboardStatsData);
        }
    }, 2400);
}


// If the document is already loaded, apply the changes immediately
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(addHeaderLayoutStyles, 2300);
}
// Add window resize event listener to update layout when screen size changes
window.addEventListener('resize', function() {
    // Wait a bit before applying changes to avoid excessive updates
    clearTimeout(window.resizeTimeout);
    window.resizeTimeout = setTimeout(function() {
        // Update the history widget header
        updateHistoryWidgetHeader();
        
        // Re-render the history tokens list if data is available
        if (currentHistoryData && currentHistoryData.length > 0) {
            renderHistoryTokensList(currentHistoryData);
        }
    }, 250);
});

// Single DOM ready handler
document.addEventListener('DOMContentLoaded', function() {
    // PHASE 1: Critical Initialization (Immediate)
    initDashboard();
    initDarkMode();
    
    // PHASE 2: Core UI Enhancements (500ms)
    setTimeout(function() {
        // Basic UI setup
        addUpdatedCSS();
        initHistoryFilterDropdown();
        
        // Apply filter enhancements
        applyDexPaidFilterChanges();
        applyMarketCapRangeFilterChanges();
        
        // Improve header layout
        addHeaderLayoutStyles();
        fixFilterDropdownPosition();
    }, 500);
    
    // PHASE 3: Advanced Features (1000ms)
    setTimeout(function() {
        // Search functionality
        applyHistorySearchBarChanges();
        
        // Additional filter metrics
        applyAdditionalMetricFilters();
        
        // Token history features
        applyTokenHistoryChanges();
        applyTokenHistoryFarmStatusChanges();
        applyRescanConsolidationChanges();
    }, 1000);
    
    // PHASE 4: Final Enhancements (1500ms)
    setTimeout(function() {
        // Apply final visual enhancements
        applyHighestThresholdChanges();
        addHistoryWidgetColorKey();
        
        // Add toggle features
        applyThresholdStatsToggleChanges();
        addTimeToggleSwitch();
        
        // Ensure proper responsive behavior
        updateHistoryWidgetHeader();
        
        // Apply incomplete scan highlighting
        highlightIncompleteScans();
        
        // Update chart titles and data
        if (farmRatioChart) updateFarmRatioChartTitle();
        if (currentHistoryData && currentHistoryData.length > 0) {
            renderHistoryTokensList(currentHistoryData);
        }
    }, 1500);
    
    // PHASE 5: Source Filter Implementation (2500ms)
    setTimeout(function() {
        console.log('Applying source filter changes');
        applySourceFilterChanges();
        addClassificationFilters();
        enhanceApplyHistoryFiltersWithClassifications();
    }, 2500);
    
    // PHASE 6: Meteora Integration (3500ms)
    setTimeout(function() {
        console.log('Applying Meteora integration');
        // Add explicit logging to debug Meteora file fetching
        console.log('Forcing complete data refresh including Meteora files');
        fetchData().then(() => {
            console.log('Data fetch complete - checking if Meteora files were loaded');
            console.log('Meteora data loaded:', 
                        currentGraduatedMeteoraData?.length || 0, 'tokens,',
                        Object.keys(currentMeteoraThresholdsData || {}).length, 'thresholds,',
                        currentGraduatedMeteoraLogData?.length || 0, 'log entries');
            
            // Refresh UI after Meteora data is loaded
            renderHistoryTokensList(currentHistoryData);
        }).catch(err => {
            console.error('Error during Meteora data fetch:', err);
        });
    }, 3500);
    
    // Add resize handler with debounce
    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            updateHistoryWidgetHeader();
            if (currentHistoryData && currentHistoryData.length > 0) {
                renderHistoryTokensList(currentHistoryData);
            }
        }, 250);
    });
});

function mergeTokenData(existingToken, newToken) {
    // If there's no existing token, just return the new token
    if (!existingToken) return newToken;
    
    // Preserve the existing token's data, but update the market cap
    return {
        ...existingToken,
        usd_market_cap: newToken.usd_market_cap,
        // Update any other fields that should refresh from the newToken
        total_supply: newToken.total_supply,
        last_updated: newToken.last_updated
    };
}
// Add this helper function if it doesn't exist
function highlightIncompleteScans() {
    console.log('Applying incomplete scan highlighting');
    const allTokenRows = document.querySelectorAll('.token-row, .token-row-with-boost');
    allTokenRows.forEach(row => {
        const copyIcon = row.querySelector('.copy-icon');
        if (!copyIcon) return;
        
        const tokenAddress = copyIcon.getAttribute('data-address');
        if (!tokenAddress) return;
        
        const isIncomplete = hasIncompleteScan(tokenAddress);
        if (isIncomplete) {
            row.classList.remove('farm-token');
            row.classList.add('incomplete-scan-token');
        }
    });
}
// Function to toggle dropdown menu
function toggleMenu() {
        document.getElementById("dropdown-menu").classList.toggle("show");
    }

    // Close the dropdown menu if the user clicks outside of it
    window.addEventListener('click', function(event) {
        if (!event.target.matches('.menu-button') && 
            !event.target.matches('.menu-button svg') && 
            !event.target.matches('.menu-button path')) {
            
            var dropdowns = document.getElementsByClassName("dropdown-content");
            for (var i = 0; i < dropdowns.length; i++) {
                var openDropdown = dropdowns[i];
                if (openDropdown.classList.contains('show')) {
                    openDropdown.classList.remove('show');
                }
            }
        }
    });
    </script>
</body>
</html>